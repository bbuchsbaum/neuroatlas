This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: R/**/*.R, R/**/*.r, *.Rmd, *.rmd, DESCRIPTION, tests/**/*.R, tests/**/*.r
- Files matching patterns in .gitignore are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
R/
  all_generic.R
  aseg_subcort.R
  atlas.R
  chart.R
  dilate_parcels.R
  fsaverage.R
  ggschaefer.R
  glasser.R
  olsen_mtl.R
  schaefer.R
  template_flow.R
  zzz.R
tests/
  testthat/
    test-dilation.R
DESCRIPTION
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tests/testthat/test-dilation.R">
test_that("dilate_parcels works on Glasser atlas", {
  skip_on_cran()  # Skip on CRAN for demonstration purposes
  
  # Load the Glasser atlas
  gl <- get_glasser_atlas()
  
  # Create a simple binary mask (all voxels of the Glasser volume)
  # Note: We convert the Glasser atlas volume to a logical mask
  mask <- as.logical(neuroim2::as.dense(gl$atlas)) 
  # Attempt dilation with small parameters just for testing
  dilated <- dilate_parcels(atlas = gl, mask = mask, radius = 2, maxn = 20)
  
  # Check that the result is a ClusteredNeuroVol
  expect_true(inherits(dilated, "ClusteredNeuroVol"))
  # Check that the dilated object still has no missing label_map entries
  expect_true(length(setdiff(unique(dilated), as.numeric(names(dilated@label_map)))) == 0)
})
</file>

<file path="R/fsaverage.R">
#' Surface geometry for the fsaverage6 atlas
#'
#' a list including left and right hemispheres for the orig, white, inflated, and pial surfaces.
#'
#' @docType data
#' @keywords datasets
#' @name fsaverage
#' @usage data(fsaverage)
"fsaverage"
</file>

<file path="R/ggschaefer.R">
#' Get ggseg-Compatible Schaefer Atlas
#'
#' @description
#' Retrieves the appropriate Schaefer atlas data structure compatible with ggseg
#' visualization based on the atlas name parameters.
#'
#' @param atlas An atlas object containing Schaefer parcellation information.
#'   The name should follow the format "schaeferN_M" where:
#'   \itemize{
#'     \item N is the number of networks (7 or 17)
#'     \item M is the number of parcels (100 to 1000 in steps of 100)
#'   }
#'
#' @return A ggseg brain atlas object for visualization
#'
#' @details
#' The function extracts the network count and parcel count from the atlas name
#' and returns the corresponding ggseg-compatible atlas object. Supports Schaefer
#' atlases with 7 or 17 networks and 100-1000 parcels (in steps of 100).
#'
#' @importFrom stringr str_extract_all
#' @import ggsegSchaefer
#' @export
get_ggseg_atlas <- function(atlas) {
  # Extract numbers from the atlas name
  matches <- stringr::str_extract_all(atlas$name, "\\d+")
  atlas_num <- unlist(matches)
  
  # Check for valid inputs
  if ((atlas_num[1] %in% seq(100, 1000, 100)) && (atlas_num[2] %in% c(7, 17))) {
    atlas_string <- paste0("schaefer", atlas_num[2], "_", atlas_num[1])
    return(get(atlas_string))
  } else {
    stop("Invalid atlas name. Must be Schaefer atlas with 7 or 17 networks and 100-1000 parcels.")
  }
}

#' Map Values to Schaefer Atlas Format
#'
#' @description
#' Converts values associated with atlas regions into a format suitable for
#' visualization with the Schaefer atlas in ggseg.
#'
#' @param atlas An atlas object containing Schaefer parcellation information
#' @param vals Numeric vector of values to map to atlas regions
#' @param thresh Numeric vector of length 2 specifying (min, max) thresholds.
#'   Values outside this range will be set to NA. Default: c(0,0)
#' @param pos Logical. If TRUE, uses raw values; if FALSE, uses absolute values
#'   for thresholding. Default: FALSE
#'
#' @return A ggseg brain atlas object with mapped values
#'
#' @importFrom assertthat assert_that
#' @importFrom dplyr mutate left_join filter
#' @importFrom tibble as_tibble
#' @importFrom ggseg as_brain_atlas
#' @export
map_to_schaefer <- function(atlas, vals, thresh=c(0,0), pos=FALSE) {
  assert_that(length(vals) == length(atlas$orig_labels),
              msg="Length of vals must match number of atlas regions")
  
  fun <- if (pos) identity else abs
  
  ggatl <- get_ggseg_atlas(atlas)
  
  ret <- tibble(
    statistic = vals,
    label = atlas$orig_labels,
    hemi = atlas$hemi
  )
  
  rboth <- ggatl %>%
    as_tibble() %>%
    mutate(label = substr(label, 15, nchar(label))) %>%
    left_join(ret) %>%
    filter(!is.na(statistic)) %>%
    mutate(statistic = ifelse(
      fun(statistic) <= thresh[1] | fun(statistic) > thresh[2],
      statistic, NA
    )) %>%
    ggseg::as_brain_atlas()
}

#' Create Interactive Schaefer Atlas Visualization
#'
#' @description
#' Creates an interactive visualization of the Schaefer atlas using ggseg,
#' with optional value mapping and customizable appearance.
#'
#' @param atlas An atlas object containing Schaefer parcellation information
#' @param vals Numeric vector of values to visualize on the atlas
#' @param thresh Numeric vector of length 2 specifying (min, max) thresholds.
#'   Values outside this range will be set to NA. Default: c(0,0)
#' @param pos Logical. If TRUE, uses raw values; if FALSE, uses absolute values
#'   for thresholding. Default: FALSE
#' @param palette Character string specifying the color palette to use.
#'   Default: "Spectral"
#' @param interactive Logical. If TRUE, creates an interactive plot with tooltips.
#'   Default: TRUE
#' @param lim Numeric vector of length 2 specifying the range for color mapping.
#'   Default: range(vals)
#'
#' @return A ggplot2 object (if interactive=FALSE) or a ggiraph object
#'   (if interactive=TRUE) showing the visualization
#'
#' @examples
#' \dontrun{
#' # Load Schaefer atlas
#' atlas <- get_schaefer_atlas("7networks", 100)
#'
#' # Create random values for visualization
#' vals <- rnorm(100)
#'
#' # Create interactive plot
#' ggseg_schaefer(atlas, vals)
#'
#' # Create static plot with custom thresholds
#' ggseg_schaefer(atlas, vals, thresh=c(-1, 1), interactive=FALSE)
#' }
#'
#' @importFrom ggplot2 aes scale_fill_distiller
#' @importFrom ggseg ggseg
#' @importFrom ggiraph girafe opts_tooltip opts_hover opts_selection
#' @importFrom scales squish
#' @export
ggseg_schaefer <- function(atlas, vals, thresh=c(0,0), pos=FALSE,
                          palette="Spectral", interactive=TRUE, lim=range(vals)) {
  gatl <- map_to_schaefer(atlas, vals, thresh, pos)
  
  ggobj <- ggseg::ggseg(
    atlas = gatl,
    position = "stacked",
    colour = "gray",
    interactive = FALSE,
    guide = TRUE,
    mapping = aes(fill = statistic, tooltip = region, data_id = label)
  ) +
    scale_fill_distiller(
      palette = palette,
      limits = lim,
      direction = -1,
      oob = scales::squish
    )
  
  if (interactive) {
    ggiraph::girafe(
      ggobj = ggobj,
      width_svg = 8,
      height_svg = 6,
      options = list(
        opts_tooltip(
          opacity = .7,
          css = "font-family: Arial, Helvetica, sans-serif;"
        ),
        opts_hover(css = "fill:yellow;"),
        opts_selection(
          css = "fill:red;",
          type = "single",
          only_shiny = FALSE
        )
      )
    )
  } else {
    ggobj
  }
}
</file>

<file path="R/zzz.R">
tflow <<- NULL

#' @import reticulate
.onLoad <- function(libname, pkgname) {
  # use superassignment to update global reference to scipy
  #tflow <<- reticulate::import("scipy", delay_load = TRUE)
  tflow <<- try(reticulate::import("templateflow", delay_load=TRUE))
  
}

#' @export
install_templateflow <- function(method = "auto", conda = "auto") {
  reticulate::py_install("scipy", method = method, conda = conda, pip=TRUE)
  reticulate::py_install("templateflow", method = method, conda = conda, pip=TRUE)
}
</file>

<file path="R/all_generic.R">
#' Extract a region of interest (ROI) from an atlas
#' 
#' @description
#' Extracts a specific region of interest from an atlas object based on label, ID,
#' and hemisphere information.
#'
#' @param x An atlas object
#' @param label Character string specifying the ROI label/name
#' @param id Numeric ID of the ROI in the atlas
#' @param hemi Character string specifying hemisphere ('left' or 'right')
#'
#' @return Returns a subset of the atlas containing only the specified ROI
#' @export
get_roi <- function(x, label, id, hemi) {
  UseMethod("get_roi")
}

#' Map values to an atlas
#' 
#' @description
#' Maps a set of values to regions/parcels in an atlas object. This can be used
#' to visualize data (like statistics or measurements) across atlas regions.
#'
#' @param x An atlas object to map values onto
#' @param vals Numeric vector of values to map to atlas regions. Length should match
#'   the number of regions in the atlas
#' @param thresh Optional numeric vector of length 2 specifying (min, max) thresholds
#'   for the mapped values. Values outside this range will be clamped.
#' @param ... Additional arguments passed to methods
#'
#' @return Returns the atlas object with mapped values
#' @export
map_atlas <- function(x, vals, thresh, ...) {
  UseMethod("map_atlas")
}

#' Reduce a NeuroVol or NeuroVec by an Atlas
#'
#' Applies a summary function to data within each ROI defined by an atlas.
#' This is an S3 generic function.
#'
#' @param atlas An atlas object or another object for which a method is defined.
#' @param data_vol A \code{NeuroVol} (3D) or \code{NeuroVec} (4D) object containing the data
#'   to be summarized.
#' @param stat_func The function to apply to the data within each ROI (e.g., \code{mean},
#'   \code{sd}, \code{sum}).
#' @param ... Additional arguments to be passed to \code{stat_func} or other methods.
#'
#' @return A \code{tibble} summarizing the data_vol by atlas regions.
#' @export
reduce_atlas <- function(atlas, data_vol, stat_func, ...) {
  UseMethod("reduce_atlas")
}
</file>

<file path="R/chart.R">
#' Plot Glasser Atlas Values
#'
#' @description
#' Creates an interactive visualization of values mapped onto the Glasser atlas
#' using echarts4r. The visualization shows both hemispheres in lateral and medial
#' views, arranged in a 2x2 grid.
#'
#' @param vals A data frame containing values to plot, must include columns:
#'   \itemize{
#'     \item label: character, matching ggseg Glasser atlas labels (e.g., "lh_L_V1")
#'     \item value: numeric, values to visualize for each region
#'   }
#'   If NULL (default), all regions will be assigned a value of 1
#' @param value_col Character string specifying the name of the column in vals containing
#'   the values to plot. Defaults to "value"
#' @param position Character string specifying layout type. Currently only "dispersed"
#'   is supported (stacked layout is planned for future versions)
#'
#' @return An echarts4r visualization object containing the 2x2 grid of brain views
#'
#' @examples
#' \dontrun{
#' # Basic visualization with uniform coloring
#' plot_glasser()
#'
#' # Create sample data
#' vals <- data.frame(
#'   label = ggsegGlasser::glasser$data$label,
#'   value = rnorm(nrow(ggsegGlasser::glasser$data))
#' )
#'
#' # Plot the data
#' plot_glasser(vals)
#'
#' # Using a different column name
#' vals$intensity <- vals$value
#' plot_glasser(vals, value_col = "intensity")
#' }
#'
#' @importFrom dplyr filter inner_join group_by summarize left_join rename mutate
#' @importFrom tidyr pivot_longer
#' @importFrom sf st_as_sf st_multipolygon st_sfc st_sf st_bbox st_geometry
#' @import ggseg
#' @import ggsegGlasser
#' @export
plot_glasser <- function(vals=NULL, value_col = "value", position = "dispersed") {
  # Check and load required packages
  required_packages <- c("geojsonio", "echarts4r")
  missing_packages <- required_packages[!sapply(required_packages, requireNamespace, quietly = TRUE)]
  if (length(missing_packages) > 0) {
    stop("The following packages are required but not installed: ", paste(missing_packages, collapse = ", "))
  }
  library(geojsonio)
  library(echarts4r)

  # Get the ggseg Glasser atlas data
  ggseg_data <- ggsegGlasser::glasser$data

  # Create default values if vals is NULL
  if (is.null(vals)) {
    vals <- data.frame(
      label = ggseg_data$label,
      value = rep(1, nrow(ggseg_data))
    )
    value_col <- "value"
  }

  if (!all(c("label", value_col) %in% colnames(vals))) {
    stop(sprintf("'vals' must contain columns 'label' and '%s'", value_col))
  }

  if (!position %in% c("dispersed", "stacked")) {
    warning("'position' must be either 'dispersed' or 'stacked'. Using 'dispersed'.")
    position <- "dispersed"
  }

  # Check if regions in vals match atlas regions
  missing_regions <- setdiff(vals$label, ggseg_data$label)
  if (length(missing_regions) > 0) {
    warning("Some regions in 'vals' are not present in the Glasser atlas")
  }

  # Join values with atlas data
  plot_data <- ggseg_data %>%
    left_join(vals, by = "label") %>%
    dplyr::rename(value = !!value_col)

  # Create the four views
  g1 <- geojsonio::geojson_json(dplyr::filter(plot_data, hemi == "left" & side == "lateral"))
  g2 <- geojsonio::geojson_json(dplyr::filter(plot_data, hemi == "right" & side == "lateral"))
  g3 <- geojsonio::geojson_json(dplyr::filter(plot_data, hemi == "left" & side == "medial"))
  g4 <- geojsonio::geojson_json(dplyr::filter(plot_data, hemi == "right" & side == "medial"))

  # Create the four charts
  chart1 <- get_chart(g1, plot_data, "value", "lat", TRUE)
  chart2 <- get_chart(g2, plot_data, "value", "med", FALSE)
  chart3 <- get_chart(g3, plot_data, "value", "lat2", FALSE)
  chart4 <- get_chart(g4, plot_data, "value", "med2", FALSE) %>%
    echarts4r::e_connect_group("4charts")

  # Arrange charts in 2x2 grid
  echarts4r::e_arrange(chart1, chart2, chart3, chart4,
                       rows = 2, cols = 2, width = "lg")
}

#' Helper Function to Create Individual Brain Charts
#' @keywords internal
#' @noRd
get_chart <- function(geo, data, var, name, show = TRUE) {
  data %>%
    echarts4r::e_charts(label) %>%
    echarts4r::e_map_register(name, geo) %>%
    echarts4r::e_map_(var, map = name, nameProperty = "label") %>%
    echarts4r::e_visual_map_(var,
                             show = show,
                             padding = 0,
                             orient = "horizontal",
                             left = "center",
                             bottom = 0
    ) %>%
    echarts4r::e_theme("dark") %>%
    echarts4r::e_group("4charts")
}

#' Helper Function to Create Individual Brain Charts
#' @keywords internal
#' @noRd
get_chart <- function(geo, data, var, name, show = TRUE) {
  data %>%
    echarts4r::e_charts(label) %>%
    echarts4r::e_map_register(name, geo) %>%
    echarts4r::e_map_(var, map = name, nameProperty = "label") %>%
    echarts4r::e_visual_map_(var,
      show = show,
      padding = 0,
      orient = "horizontal",
      left = "center",
      bottom = 0
    ) %>%
    echarts4r::e_theme("dark") %>%
    echarts4r::e_group("4charts")
}
</file>

<file path="R/glasser.R">
#' Load Glasser Atlas
#'
#' @description
#' Retrieves and loads the Glasser360 cortical parcellation atlas from the PennBBL
#' repository. The atlas provides a detailed parcellation of the human cerebral cortex
#' based on multi-modal neuroimaging data.
#'
#' @details
#' The Glasser atlas divides each hemisphere into 180 areas (360 total) based on
#' cortical architecture, function, connectivity, and topography. The atlas is
#' downloaded from the PennBBL xcpEngine repository and includes:
#' \itemize{
#'   \item Volume data in MNI space
#'   \item Region labels and hemisphere information
#'   \item Color specifications for visualization
#' }
#'
#' @param outspace Optional \code{NeuroSpace} object specifying desired output space.
#'   If provided, the atlas will be resampled to this space. Default: NULL
#'
#' @return A list with class 'glasser' and 'atlas' containing:
#' \describe{
#'   \item{name}{Character string "Glasser360"}
#'   \item{atlas}{A \code{ClusteredNeuroVol} object containing the parcellation}
#'   \item{cmap}{Data frame with RGB color specifications for each region}
#'   \item{ids}{Integer vector of region IDs (1:360)}
#'   \item{labels}{Character vector of anatomical labels}
#'   \item{hemi}{Character vector indicating hemisphere ('left' or 'right')}
#' }
#'
#' @references
#' Glasser, M. F., et al. (2016). A multi-modal parcellation of human cerebral
#' cortex. Nature, 536(7615), 171-178.
#'
#' @source
#' Atlas files are downloaded from:
#' \url{https://github.com/PennBBL/xcpEngine/tree/master/atlas/glasser360}
#'
#' @examples
#' \dontrun{
#' # Load atlas in native space
#' atlas <- get_glasser_atlas()
#'
#' # View region labels
#' head(atlas$labels)
#'
#' # Check number of regions per hemisphere
#' table(atlas$hemi)
#' }
#'
#' @importFrom neuroim2 read_vol ClusteredNeuroVol
#' @importFrom downloader download
#' @export
get_glasser_atlas <- function(outspace=NULL) {
  # Download and read atlas volume
  fname <- "glasser360MNI.nii.gz"
  rpath <- "https://github.com/PennBBL/xcpEngine/raw/master/atlas/glasser360/"
  path <- paste0(rpath, fname)
  
  des <- paste0(tempdir(), "/", fname)
  ret <- download(path, des)
  
  vol <- neuroim2::read_vol(des)
  
  if (!is.null(outspace)) {
    vol <- resample(vol, outspace)
  }
  
  # Download and process labels
  label_name <- "glasser360NodeNames.txt"
  des2 <- paste0(tempdir(), "/", label_name)
  ret <- download(paste0(rpath, label_name), des2)
  
  labels <- read.table(des2, as.is=TRUE)
  cols <- t(col2rgb(rainbow(nrow(labels))))
  colnames(cols) <- c("red", "green", "blue")
  cols <- as.data.frame(cols)
  hemi <- tolower(sapply(strsplit(labels[,1], "_"), "[[", 1))
  region <- sapply(strsplit(labels[,1], "_"), "[[", 2)
  
  # Create label mapping
  cids <- 1:nrow(labels)
  label_map <- as.list(cids)
  names(label_map) <- region
  
  vol <- neuroim2::ClusteredNeuroVol(as.logical(vol), 
                                    clusters=vol[vol!=0], 
                                    label_map=label_map)
  
  # Return atlas object
  ret <- list(
    name="Glasser360",
    atlas=vol,
    cmap=cols,
    ids=1:nrow(labels),
    labels=region,
    hemi=hemi)
  
  class(ret) <- c("glasser", "atlas")
  ret
}

#' Map Values to Glasser Atlas
#'
#' @description
#' Maps numeric values to regions in the Glasser atlas for visualization using
#' ggseg plotting functions.
#'
#' @param x A Glasser atlas object
#' @param vals Numeric vector of values to map to atlas regions
#' @param thresh Numeric vector of length 2 specifying (min, max) thresholds.
#'   Values outside this range will be set to NA
#' @param pos Logical. If TRUE, uses raw values; if FALSE, uses absolute values
#'   for thresholding
#' @param ... Additional arguments passed to methods
#'
#' @return A ggseg brain atlas object with mapped values
#'
#' @import ggsegGlasser
#' @importFrom ggiraph geom_polygon_interactive
#' @importFrom dplyr left_join mutate
#' @importFrom tibble tibble
#' @export
map_atlas.glasser <- function(x, vals, thresh=c(0,0), pos=FALSE, ...) {
  fun <- if (pos) identity else abs
  
  ids <- ifelse(x$hemi == "left", 
                paste0("lh_L_", x$label), 
                paste0("rh_R_", x$label))
  
  ret <- tibble(statistic=vals, region=x$labels, label=ids, hemi=x$hemi)
  
  rboth <- ggsegGlasser::glasser %>%
    as_tibble() %>%
    left_join(ret) %>%
    mutate(statistic=ifelse(fun(statistic) <= thresh[1] | 
                           fun(statistic) > thresh[2], 
                           statistic, NA)) %>%
    as_brain_atlas()
  
  rboth
}

#' Plot Glasser Atlas
#'
#' @description
#' Creates an interactive visualization of the Glasser atlas with mapped values
#' using ggseg and ggiraph.
#'
#' @param x A Glasser atlas object
#' @param y Ignored (required for compatibility with generic plot method)
#' @param vals Numeric vector of values to visualize. If NULL (default), all regions
#'   will be assigned a value of 1, creating a uniform visualization
#' @param thresh Numeric vector of length 2 for thresholding values
#' @param pos Logical. If TRUE, uses raw values for thresholding
#' @param position Character. Layout type ("stacked" or "dispersed")
#' @param colour Character. Border color for regions
#' @param guide Logical. Whether to show color guide
#' @param palette Character. Name of scico color palette
#' @param lim Numeric vector of length 2 for color scale limits. If NULL, will be
#'   set to range of vals
#' @param ... Additional arguments passed to methods
#'
#' @return A ggiraph interactive plot object
#'
#' @importFrom tibble tibble
#' @importFrom magrittr %>%
#' @importFrom dplyr mutate left_join
#' @importFrom ggiraph girafe opts_tooltip opts_hover opts_selection
#' @importFrom ggplot2 aes
#' @importFrom scico scale_fill_scico
#' @import scico
#' @export
plot.glasser <- function(x, y, vals=NULL, thresh=c(0,0), pos=FALSE, 
                        position="stacked", colour="gray", guide=TRUE,
                        palette="cork", lim=NULL, ...) {
  if (is.null(vals)) {
    vals <- rep(1, length(x$labels))
  }
  
  if (is.null(lim)) {
    lim <- range(vals)
  }
  
  gatl <- map_atlas(x, vals, thresh=thresh, pos=pos)
  
  gg <- ggseg(atlas=gatl, 
              position=position, 
              colour=colour, 
              interactive=FALSE, 
              guide=guide,
              mapping=aes(fill=statistic, 
                         tooltip=region,
                         data_id=label)) + 
    scale_fill_scico(palette=palette,
                     limits=lim,
                     direction=-1,
                     oob=scales::squish)
  
  girafe(ggobj=gg,
         width_svg=8, 
         height_svg=6, 
         options=list(
           opts_tooltip(opacity=.7,
                       css="font-family: Arial, Helvetica, sans-serif;"),
           opts_hover(css="fill:yellow;"),
           opts_selection(css="fill:red;", 
                         type="single", 
                         only_shiny=FALSE)))
}

#' Print Method for Glasser Atlas Objects
#'
#' @description
#' Displays a formatted summary of a Glasser atlas object, including region counts,
#' hemisphere distribution, and basic metadata.
#'
#' @param x A Glasser atlas object
#' @param ... Additional arguments passed to print methods
#'
#' @importFrom crayon bold green blue red white yellow
#' @importFrom cli rule symbol
#' @export
print.glasser <- function(x, ...) {
  # Header with fancy border
  cat(cli::rule(left = crayon::bold(crayon::blue("Glasser Atlas Summary")), 
                col = "cyan", width = 65), "\n\n")
  
  # Basic info section
  cat(crayon::yellow(cli::symbol$info), " ", 
      crayon::bold("Atlas Type: "), 
      crayon::white("Glasser Multi-Modal Parcellation"), "\n", sep="")
  
  cat(crayon::yellow(cli::symbol$info), " ",
      crayon::bold("Resolution: "), 
      crayon::white("MNI Space"), "\n", sep="")
  
  # Volume dimensions
  dims <- dim(x$atlas)
  cat(crayon::yellow(cli::symbol$info), " ",
      crayon::bold("Dimensions: "), 
      crayon::white(paste0(dims[1], " × ", dims[2], " × ", dims[3])), "\n\n", sep="")
  
  # Region counts
  total_regions <- length(x$ids)
  left_regions <- sum(x$hemi == "left")
  right_regions <- sum(x$hemi == "right")
  
  cat(crayon::green(cli::symbol$circle_filled), " ",
      crayon::bold("Region Summary:"), "\n", sep="")
  
  cat(crayon::blue("├─"), " Total Regions:      ", 
      crayon::white(total_regions), "\n", sep="")
  cat(crayon::blue("├─"), " Left Hemisphere:    ", 
      crayon::white(left_regions), "\n", sep="")
  cat(crayon::blue("└─"), " Right Hemisphere:   ", 
      crayon::white(right_regions), "\n\n", sep="")
  
  # Sample regions
  cat(crayon::green(cli::symbol$circle_filled), " ",
      crayon::bold("Example Regions:"), "\n", sep="")
  
  # Show first 3 regions from each hemisphere
  left_examples <- head(x$labels[x$hemi == "left"], 3)
  right_examples <- head(x$labels[x$hemi == "right"], 3)
  
  cat(crayon::blue("├─"), " Left:  ", 
      crayon::white(paste(left_examples, collapse=", ")), "...\n", sep="")
  cat(crayon::blue("└─"), " Right: ", 
      crayon::white(paste(right_examples, collapse=", ")), "...\n", sep="")
  
  # Footer
  cat("\n", cli::rule(
    left = crayon::blue(cli::symbol$info), 
    right = "Use plot() for visualization",
    col = "cyan", width = 65), "\n", sep="")
}
</file>

<file path="R/template_flow.R">
# New TemplateFlow Core Interface (WIP - Ticket 1)

#' @importFrom tools R_user_dir
#' @importFrom reticulate import py_available py_module_available py_has_attr py_get_attr py_list_attributes py_capture_error py_to_r is_py_object
#' @importFrom memoise memoise
#' @importFrom lifecycle deprecate_warn
#' @importFrom utils modifyList head askYesNo

# Environment and Cache Setup ----

#' TemplateFlow API Handle and Configuration
#'
#' This object acts as a gateway to the Python TemplateFlow API and manages
#' neuroatlas-specific configurations like caching.
#'
#' @keywords internal
.tflow_env <- new.env(parent = emptyenv())

#' Get or Create neuroatlas Cache Directory
#'
#' Returns a path to a neuroatlas-specific cache directory. If the directory
#' (or a specified subdirectory) doesn't exist, it will be created.
#' This function uses `tools::R_user_dir` to ensure a user-specific, 
#' OS-appropriate cache location.
#'
#' @param subdir Optional character string. If provided, a subdirectory named
#'   `subdir` will be created/used within the main neuroatlas cache directory.
#' @return A character string representing the path to the cache directory.
#' @keywords internal
.neuroatlas_cache_dir <- function(subdir = NULL) {
  base_cache_dir <- tools::R_user_dir("neuroatlas", "cache")
  
  cache_path <- base_cache_dir
  if (!is.null(subdir) && nzchar(subdir)) {
    cache_path <- file.path(base_cache_dir, subdir)
  }
  
  if (!dir.exists(cache_path)) {
    dir.create(cache_path, recursive = TRUE, showWarnings = FALSE)
  }
  
  return(cache_path)
}

#' Initialize and Get TemplateFlow API Handle
#'
#' Establishes connection to the Python TemplateFlow API via reticulate.
#' Stores the API handle and cache path in an internal environment.
#' It also sets the TEMPLATEFLOW_HOME environment variable to ensure the 
#' Python library uses the neuroatlas-managed cache directory.
#'
#' @param cache_dir The directory to use for caching TemplateFlow files managed by neuroatlas.
#'                  Defaults to `.neuroatlas_cache_dir("templateflow")`.
#'                  If provided, this path will be used for TEMPLATEFLOW_HOME.
#' @param force_reinit Logical, whether to force re-initialization of the Python API handle.
#' @return Invisibly returns the TemplateFlow S3 object.
#' @keywords internal
.init_templateflow_api <- function(cache_dir = NULL, force_reinit = FALSE) {
  # Determine and set the cache directory first, as it influences TEMPLATEFLOW_HOME
  current_tf_home <- Sys.getenv("TEMPLATEFLOW_HOME")
  target_cache_dir <- ""

  if (!is.null(cache_dir)) {
    # User explicitly provided a cache_dir for this initialization
    target_cache_dir <- cache_dir
    .tflow_env$cache_dir <- target_cache_dir # Store for the R object
    if (!dir.exists(target_cache_dir)) {
      dir.create(target_cache_dir, recursive = TRUE, showWarnings = FALSE)
    }
  } else if (!is.null(.tflow_env$cache_dir) && !force_reinit) {
    # Use previously initialized cache_dir if not forcing reinit and no new one provided
    target_cache_dir <- .tflow_env$cache_dir
  } else {
    # Default: use .neuroatlas_cache_dir("templateflow")
    target_cache_dir <- .neuroatlas_cache_dir("templateflow")
    .tflow_env$cache_dir <- target_cache_dir # Store for the R object
  }
  
  # Set TEMPLATEFLOW_HOME before importing the Python module, 
  # but only if it's not already set or if we are forcing a change.
  # If TEMPLATEFLOW_HOME is already set externally, respect it unless cache_dir is given.
  if (current_tf_home == "" || !is.null(cache_dir) || force_reinit) {
      if (current_tf_home != target_cache_dir) {
          Sys.setenv(TEMPLATEFLOW_HOME = target_cache_dir)
          if (!is.null(.tflow_env$api)) { 
            force_reinit <- TRUE
            message("TEMPLATEFLOW_HOME changed to: ", target_cache_dir, ". Re-initializing Python API.")
          }
      }
  } else if (current_tf_home != "" && current_tf_home != target_cache_dir && is.null(cache_dir)) {
    message("Using externally set TEMPLATEFLOW_HOME: ", current_tf_home)
    .tflow_env$cache_dir <- current_tf_home 
    target_cache_dir <- current_tf_home
  }

  if (is.null(.tflow_env$api) || force_reinit) {
    if (!reticulate::py_available(initialize = TRUE)) {
      stop("Python is not available. \"reticulate\" needs Python to access TemplateFlow.")
    }
    if (!reticulate::py_module_available("templateflow")) {
      stop("Python module 'templateflow' is not installed. Please install it, e.g., via: \n           reticulate::py_install('templateflow')")
    }
    tryCatch({
      .tflow_env$py_api <- reticulate::import("templateflow.api", convert = TRUE)
    }, error = function(e) {
      stop("Failed to import templateflow.api: ", e$message)
    })
  }
  
  invisible(NULL)
}

# Memoised TemplateFlow Path Fetching ----

#' Perform TemplateFlow API Call and Convert to Path
#' 
#' Internal function that calls the Python TemplateFlow API's get() method,
#' handles errors, and converts the result (potentially a list of paths)
#' to a single R file path string. If multiple paths are returned by TemplateFlow,
#' a warning is issued and the first path is used.
#'
#' @param tf_api_obj The Python TemplateFlow API object from reticulate.
#' @param query_params_list A named list of query parameters for `tf_api_obj$get()`.
#' @return A single character string representing the file path.
#' @keywords internal
.perform_tf_get_and_convert_to_path <- function(tf_api_obj, query_params_list) {
  py_result_path_obj <- NULL
  
  # Capture Python errors from the API call
  py_error <- reticulate::py_capture_error({
    py_result_path_obj <- do.call(tf_api_obj$get, query_params_list)
  })

  if (!is.null(py_error)) {
    stop(structure(
      list(message = paste0("TemplateFlow API error: ", py_error$message,
                            "\nQuery args: ", paste(names(query_params_list), query_params_list, sep="=", collapse=", ")),
           call = NULL,
           query_args = query_params_list,
           python_error = py_error),
      class = c("templateflow_api_error", "error", "condition")
    ))
  }

  if (is.null(py_result_path_obj)) {
    stop(structure(
      list(message = paste0("TemplateFlow found no files for the given query.",
                            "\nQuery args: ", paste(names(query_params_list), query_params_list, sep="=", collapse=", ")),
           call = NULL,
           query_args = query_params_list),
      class = c("templateflow_no_files_error", "error", "condition")
    ))
  }

  final_py_path_obj_to_convert <- NULL
  # Check if the result is a Python list object
  if (reticulate::is_py_object(py_result_path_obj) && inherits(py_result_path_obj, "python.builtin.list")) {
    num_paths <- length(py_result_path_obj)
    if (num_paths > 1) {
      first_path_str <- tryCatch(reticulate::py_to_r(py_result_path_obj[[1]]$as_posix()), error = function(e) "<unavailable>")
      warning("TemplateFlow returned multiple files (", num_paths, ") for the query, using the first one: ", first_path_str, call. = FALSE)
      final_py_path_obj_to_convert <- py_result_path_obj[[1]]
    } else if (num_paths == 1) {
      final_py_path_obj_to_convert <- py_result_path_obj[[1]]
    } else { # num_paths == 0
      # This case should ideally be caught by `is.null(py_result_path_obj)` check earlier
      # if TemplateFlow returns NULL for empty list, or an actual empty list.
      # If it's an empty Python list, py_result_path_obj would not be NULL.      
      stop(structure(
        list(message = paste0("TemplateFlow returned an empty list of files for the query.",
                              "\nQuery args: ", paste(names(query_params_list), query_params_list, sep="=", collapse=", ")),
             call = NULL,
             query_args = query_params_list),
        class = c("templateflow_no_files_error", "error", "condition")
      ))
    }
  } else { # Not a Python list, assume it's a single Python Path object or similar
    final_py_path_obj_to_convert <- py_result_path_obj
  }

  if (is.null(final_py_path_obj_to_convert)) {
     # Should not happen if logic above is correct, but as a safeguard:
     stop(structure(
        list(message = paste0("Failed to determine a single path from TemplateFlow's response.",
                              "\nQuery args: ", paste(names(query_params_list), query_params_list, sep="=", collapse=", ")),
             call = NULL,
             query_args = query_params_list),
        class = c("templateflow_processing_error", "error", "condition")
      ))
  }
  
  # Convert the Python Path object to an R string path
  r_path_string <- tryCatch({
    reticulate::py_to_r(final_py_path_obj_to_convert$as_posix())
  }, error = function(e_conv) {
    stop(structure(
        list(message = paste0("Failed to convert Python path object to R string: ", e_conv$message,
                              "\nQuery args: ", paste(names(query_params_list), query_params_list, sep="=", collapse=", ")),
             call = NULL,
             query_args = query_params_list,
             conversion_error = e_conv),
        class = c("templateflow_conversion_error", "error", "condition")
      ))
  })
  
  return(r_path_string)
}

#' Memoised version of .perform_tf_get_and_convert_to_path
#' @keywords internal
.memoised_fetch_templateflow_path <- memoise::memoise(.perform_tf_get_and_convert_to_path)


# TemplateFlow S3 Object and Methods ----

#' Create a TemplateFlow Interface Object
#'
#' Initializes and returns an S3 object of class \code{templateflow} which acts as
#' a gateway to the TemplateFlow Python API and manages configurations.
#'
#' @param cache_dir Optional. Path to a directory for caching TemplateFlow downloads.
#'                  If NULL (default), uses a neuroatlas-specific cache directory obtained
#'                  via \code{.neuroatlas_cache_dir("templateflow")}. 
#'                  This will also set the \code{TEMPLATEFLOW_HOME} environment variable for the Python session.
#' @param verbosity Optional. An integer for verbosity level (not yet implemented).
#' @param default_template Optional. A string for a default template to use (not yet implemented).
#'
#' @return An S3 object of class \code{templateflow} containing:
#'   \itemize{
#'     \item \code{api}: The raw Python TemplateFlow API handle from \code{reticulate}.
#'     \item \code{cache_path}: The R-side cache path being used.
#'     \item \code{options}: A list of user-provided options.
#'   }
#' @export
#' @examples
#' \dontrun{
#'   # Ensure Python and templateflow module are available
#'   if (reticulate::py_available(initialize = TRUE) && 
#'       reticulate::py_module_available("templateflow")) {
#'     tf <- create_templateflow()
#'     print(tf)
#'   } else {
#'     message("Python or templateflow module not available. Skipping example.")
#'   }
#' }
create_templateflow <- function(cache_dir = NULL, verbosity = 0, default_template = NULL) {
  .init_templateflow_api(cache_dir = cache_dir) # Ensures API handle and cache_dir are in .tflow_env
  
  obj <- list(
    api = .tflow_env$py_api, # Direct access to the Python API object
    cache_path = .tflow_env$cache_dir,
    options = list(
      verbosity = verbosity,
      default_template = default_template
    )
  )
  
  class(obj) <- "templateflow"
  return(obj)
}

#' Print a TemplateFlow Object
#'
#' Provides a brief summary of the TemplateFlow interface object.
#'
#' @param x An object of class \code{templateflow}.
#' @param ... Additional arguments (unused).
#' @export
print.templateflow <- function(x, ...) {
  cat("<neuroatlas TemplateFlow Interface>\n")
  cat("  Cache Path: ", x$cache_path, "\n")
  # Basic check if API object seems valid
  api_status <- tryCatch({
    if (!is.null(x$api) && reticulate::py_has_attr(x$api, "get")) {
      "Connected (Python API handle initialized)"
    } else {
      "Disconnected (Python API handle NOT initialized or invalid)"
    }
  }, error = function(e) "Error checking API status")
  cat("  API Status: ", api_status, "\n")
  
  # Attempt to list some available templates (T5.1.3)
  if (api_status == "Connected (Python API handle initialized)") {
    example_templates <- NULL
    tryCatch({
      # Use the new tflow_spaces function, pass the api_handle
      all_templates <- tflow_spaces(api_handle = x) 
      if (!is.null(all_templates) && length(all_templates) > 0) {
        cat("  Available Templates (Examples): ", paste(utils::head(all_templates, 5), collapse=", "))
        if (length(all_templates) > 5) {
          cat(", ... (Total: ", length(all_templates), ")\n", sep="")
        } else {
          cat(" (Total: ", length(all_templates), ")\n", sep="")
        }
      } else if (!is.null(all_templates)) { # empty list returned
        cat("  Available Templates: None found or list is empty.\n")
      } # If NULL, a warning was already issued by tflow_spaces
    }, error = function(e) {
      cat("  Available Templates: Error retrieving list - ", e$message, "\n")
    })
  } else {
    cat("  Available Templates: Cannot list (API not connected).\n")
  }
  
  invisible(x)
}

#' Access Attributes of the TemplateFlow Object
#'
#' Allows R-native access (via \code{$}) to attributes and methods of the 
#' underlying Python TemplateFlow API object.
#'
#' @param x An object of class \code{templateflow}.
#' @param name The name of the attribute or method to access on the Python object.
#' @return The attribute or method from the Python TemplateFlow API object.
#' @export
#' @method $ templateflow
#' @examples
#' \dontrun{
#'   # Ensure Python and templateflow module are available
#'   if (reticulate::py_available(initialize = TRUE) && 
#'       reticulate::py_module_available("templateflow")) {
#'     tf <- create_templateflow()
#'     # Example: Access the 'get' method (it's a Python function)
#'     # print(tf$get) 
#'     # Example: List available templates (calls tf$api$templates())
#'     # print(tf$templates()) 
#'   } else {
#'     message("Python or templateflow module not available. Skipping example.")
#'   }
#' }
`$.templateflow` <- function(x, name) {
  if (is.null(x$api)) {
    stop("TemplateFlow API handle is not initialized. Call create_templateflow() again.")
  }
  if (!reticulate::py_has_attr(x$api, name)) {
    # Before stopping, check if it's a valid template ID to provide a better error or future enhancement
    # For now, just indicate attribute not found on the API object itself.
    available_attrs <- reticulate::py_list_attributes(x$api)
    stop(paste0("No attribute or method named '", name, "' found on the TemplateFlow API object. ",
                "Available attributes: ", paste(available_attrs, collapse=", "))) 
  }
  reticulate::py_get_attr(x$api, name)
}

#' Access Attributes of the TemplateFlow Object using [[
#'
#' Allows R-native access (via \code{[[}) to attributes and methods of the 
#' underlying Python TemplateFlow API object.
#'
#' @param x An object of class \code{templateflow}.
#' @param name The name of the attribute or method to access on the Python object.
#' @return The attribute or method from the Python TemplateFlow API object.
#' @export
#' @method [[ templateflow
#' @examples
#' \dontrun{
#'   # Ensure Python and templateflow module are available
#'   if (reticulate::py_available(initialize = TRUE) && 
#'       reticulate::py_module_available("templateflow")) {
#'     tf <- create_templateflow()
#'     # Example: Access the 'get' method (it's a Python function)
#'     # print(tf[["get"]]) 
#'   } else {
#'     message("Python or templateflow module not available. Skipping example.")
#'   }
#' }
`[[.templateflow` <- function(x, name) {
  # Forward to the $ method for now, as behavior is identical for this object structure
  # This also means any error handling in $ applies here too.
  x$api[[name]]
}

#' List Attributes of the TemplateFlow API Object
#'
#' Lists the names of attributes and methods available on the underlying
#' Python TemplateFlow API object.
#'
#' @param x An object of class \code{templateflow}.
#' @return A character vector of available attribute and method names.
#' @export
#' @method names templateflow
#' @examples
#' \dontrun{
#'   # Ensure Python and templateflow module are available
#'   if (reticulate::py_available(initialize = TRUE) && 
#'       reticulate::py_module_available("templateflow")) {
#'     tf <- create_templateflow()
#'     # print(names(tf)) 
#'   } else {
#'     message("Python or templateflow module not available. Skipping example.")
#'   }
#' }
names.templateflow <- function(x) {
  if (is.null(x$api)) {
    stop("TemplateFlow API handle is not initialized. Call create_templateflow() again.")
  }
  reticulate::py_list_attributes(x$api)
}

#' Fetch a Template from TemplateFlow
#'
#' Unified function to retrieve neuroimaging templates and related files from
#' the TemplateFlow repository. This function provides a more R-native interface
#' to the underlying Python \code{templateflow.api.get()} method.
#'
#' @param space Character string. The primary TemplateFlow identifier for the template space
#'   (e.g., \code{"MNI152NLin2009cAsym"}). Default: \code{"MNI152NLin2009cAsym"}.
#' @param variant Character string. A high-level descriptor for common template types.
#'   Supported: \code{"brain"} (default), \code{"head"}, \code{"mask"}, \code{"probseg"}, \code{"dseg"}.
#'   This is used to infer \code{desc} and sometimes \code{suffix} if they are not explicitly provided.
#' @param modality Character string. The imaging modality or primary suffix for the template file.
#'   Supported: \code{"T1w"} (default), \code{"T2w"}, \code{"mask"} (often used with \code{variant="mask"}).
#'   This is used to infer \code{suffix} if not explicitly provided.
#' @param resolution Numeric or character. The resolution of the template in mm (e.g., \code{1}, \code{2}, \code{"1"}, \code{"01"}). Default: \code{1}.
#' @param cohort Character string. Optional cohort identifier (e.g., \code{" अधोक्षज"}).
#' @param desc Character string. Specific TemplateFlow \code{desc} field. If provided, this overrides
#'   any \code{desc} inferred from \code{variant}.
#' @param label Character string. Specific TemplateFlow \code{label} field (e.g., \code{"GM"}, \code{"WM"}, \code{"CSF"} for \code{variant="probseg"} or \code{variant="dseg"}).
#' @param atlas Character string. Specific TemplateFlow \code{atlas} field (e.g., \code{"Schaefer2018"}).
#' @param suffix Character string. Specific TemplateFlow \code{suffix} field. If provided, this overrides
#'   any \code{suffix} inferred from \code{modality} or \code{variant}.
#' @param extension Character string. The file extension. Default: \code{".nii.gz"}.
#' @param path_only Logical. If \code{TRUE}, returns the file path to the template as a string
#'   instead of loading it as a \code{NeuroVol} object. Default: \code{FALSE}.
#' @param use_cache Logical. (Currently primarily for future R-level memoisation).
#'   TemplateFlow's Python API has its own caching. Default: `TRUE`.
#'   Actual R-level path memoisation is now active.
#' @param api_handle An optional S3 object of class `templateflow` obtained from
#'   `create_templateflow()`. If `NULL` (default), a default instance is created internally.
#' @param ... Additional arguments passed directly to the Python `templateflow.api.get()` method
#'   (e.g., `raise_on_empty = TRUE`). This allows specifying any valid TemplateFlow query 
#'   entity not explicitly listed as a parameter (e.g., `hemi`, `den`).
#'
#' @details 
#' The function performs several pre-flight checks:
#'   - Validates the existence of the specified `space` using `tf$api$templates()`.
#'   - Validates the specified `resolution` against available resolutions for that `space` using `tf$api$resolutions()`.
#'   - These checks issue warnings and may be skipped if the necessary metadata cannot be retrieved from TemplateFlow.
#' 
#' Caching behavior:
#'   - This function uses `memoise` to cache the resolved file paths from TemplateFlow at the R level for the current session.
#'   - The underlying Python TemplateFlow library also maintains its own disk cache, typically configured via the 
#'     `TEMPLATEFLOW_HOME` environment variable (which this package helps manage).
#'
#' @return If any of `space`, `variant`, `modality`, `resolution`, or `label` are vectors
#'   of length > 1 (and only one of them is vectorized per call), a named list of results is returned.
#'   The names of the list elements correspond to the values of the vectorized parameter.
#'   If all parameters are scalar (or vectors of length 1), a single \code{neuroim2::NeuroVol} object
#'   or a file path string is returned directly (depending on \code{path_only}).
#'
#' @importFrom reticulate py_capture_error py_get_attr
#' @importFrom neuroim2 NeuroVol
#' @export
#' @examples
#' \dontrun{
#'   # Ensure Python and templateflow module are available
#'   if (reticulate::py_available(initialize = TRUE) && 
#'       reticulate::py_module_available("templateflow")) {
#'     
#'     # Get default MNI T1w brain template (scalar call)
#'     mni_brain <- get_template()
#'     print(mni_brain)
#' 
#'     # Vectorized call: Get MNI brain and mask variants
#'     # mni_variants <- get_template(variant = c("brain", "mask"))
#'     # print(names(mni_variants))
#'     # print(mni_variants$brain)
#'     # print(mni_variants$mask)
#'
#'     # Vectorized call: Get MNI T1w at 1mm and 2mm resolutions
#'     # mni_resolutions <- get_template(resolution = c(1, 2))
#'     # print(mni_resolutions$`1`)
#'     # print(mni_resolutions$`2`)
#'
#'     # Vectorized call: Get GM and CSF probseg for MNI
#'     # mni_probsegs <- get_template(variant = "probseg", label = c("GM", "CSF"))
#'     # print(mni_probsegs$GM)
#'
#'     # Path only example with vectorization
#'     # mni_mask_paths <- get_template(space = "MNI152NLin2009cAsym", 
#'     #                              variant = "mask", 
#'     #                              resolution = c(1,2), 
#'     #                              path_only = TRUE)
#'     # print(mni_mask_paths)
#'
#'   } else {
#'     message("Python or templateflow module not available. Skipping example.")
#'   }
#' }
get_template <- function(space = "MNI152NLin2009cAsym", 
                         variant = "brain", 
                         modality = "T1w", 
                         resolution = 1,
                         cohort = NULL, 
                         desc = NULL, 
                         label = NULL, 
                         atlas = NULL, 
                         suffix = NULL, 
                         extension = ".nii.gz",
                         path_only = FALSE, 
                         use_cache = TRUE, 
                         api_handle = NULL, 
                         ...) {

  # --- Vectorized Argument Handling (T2.3.1) --- 
  vectorizable_params <- list(space = space, variant = variant, modality = modality, resolution = resolution, label = label)
  vector_lengths <- sapply(vectorizable_params, length)
  is_actually_vectorized <- vector_lengths > 1
  num_vectorized_args <- sum(is_actually_vectorized)

  if (num_vectorized_args > 1) {
    stop("Vectorization is supported for only one of these parameters at a time: 'space', 'variant', 'modality', 'resolution', 'label'.\n         Please use a loop or an apply-family function (e.g., lapply, purrr::map) for combinatorial retrieval.")
  }

  if (num_vectorized_args == 1) {
    vectorized_param_name <- names(is_actually_vectorized[is_actually_vectorized])
    vectorized_values <- vectorizable_params[[vectorized_param_name]]
    
    # Ensure `...` is captured correctly for recursive calls
    dot_args <- list(...)

    results_list <- lapply(vectorized_values, function(current_iter_value) {
      # Construct the argument list for the recursive call to get_template
      recursive_args <- list(
        cohort = cohort, 
        desc = desc, 
        atlas = atlas, 
        suffix = suffix,
        extension = extension, 
        path_only = path_only, 
        use_cache = use_cache,
        api_handle = api_handle
      )
      
      # Set scalar values for parameters that were originally passed as single-length or NULL
      # and set the current iteration value for the one parameter that is being vectorized.
      recursive_args$space      <- if (vectorized_param_name == "space") current_iter_value else space[1]
      recursive_args$variant    <- if (vectorized_param_name == "variant") current_iter_value else variant[1]
      recursive_args$modality   <- if (vectorized_param_name == "modality") current_iter_value else modality[1]
      recursive_args$resolution <- if (vectorized_param_name == "resolution") current_iter_value else resolution[1]
      recursive_args$label      <- if (vectorized_param_name == "label") current_iter_value else label[1]
      
      # Combine with original ... arguments
      final_recursive_args <- c(recursive_args, dot_args)
      
      # Remove any NULL elements that might have been introduced (e.g. if original label was NULL)
      final_recursive_args <- Filter(Negate(is.null), final_recursive_args)
      
      # Make the recursive call. Using do.call ensures arguments are passed correctly.
      # Need to ensure we are calling the correct get_template (e.g. from this package if developing)
      # If this code is inside the neuroatlas package, neuroatlas::get_template is appropriate.
      # If used interactively for testing, get_template might be sufficient if in global env.
      # For safety in package code: use fully qualified name or ensure correct dispatch.
      do.call(neuroatlas::get_template, final_recursive_args)
    })
    
    names(results_list) <- as.character(vectorized_values)
    return(results_list)
  }
  # --- End Vectorized Argument Handling ---

  # --- Original scalar logic continues below ---
  if (is.null(api_handle)) {
    tf <- create_templateflow() 
  } else {
    if (!inherits(api_handle, "templateflow")) {
      stop("'api_handle' must be an object of class 'templateflow' from create_templateflow().")
    }
    tf <- api_handle
  }

  if (is.null(tf$api)) {
    stop("TemplateFlow API handle is not initialized. Python or 'templateflow' module might be missing.")
  }

  # Pre-flight check: Validate the template space (T4.1.1)
  # Note: tf$api$templates() returns Python list, needs conversion for `is.element`
  available_templates_py <- NULL
  tryCatch({
    available_templates_py <- tf$api$templates()
  }, error = function(e) {
    warning(paste0("Could not retrieve list of available TemplateFlow templates: ", e$message, ". Proceeding without space validation."))
  })
  
  if (!is.null(available_templates_py)){
    available_templates_r <- reticulate::py_to_r(available_templates_py)
    if (!is.element(space, available_templates_r)) {
      stop(paste0("Template space '", space, "' not found in TemplateFlow. \n",
                  "Available top-level template spaces are: ", paste(available_templates_r, collapse=", "), ".\n",
                  "Please check the space identifier or consult https://www.templateflow.org/usage/templateflow-archive/"))
    }
  }

  # Pre-flight check: Validate resolution for the given space (T4.1.2)
  # tf$api$resolutions(space) returns Python list of strings
  if (!is.null(resolution)) { # Only check if resolution is provided
    available_resolutions_py <- NULL
    tryCatch({
      available_resolutions_py <- tf$api$resolutions(space)
    }, error = function(e) {
      warning(paste0("Could not retrieve available resolutions for space '", space, "': ", e$message, ". Proceeding without resolution validation."))
    })

    if (!is.null(available_resolutions_py)) {
      available_resolutions_r <- reticulate::py_to_r(available_resolutions_py)
      # Ensure comparison is between character versions
      requested_res_char <- as.character(resolution)
      
      # TemplateFlow resolutions might be '1', '2' or '01', '02'. 
      # We should be flexible. For now, assume direct string match works.
      # If user provides 1 and TF has "01", this might fail. 
      # The query_args construction already does as.character(resolution), so let's test that.
      # A more robust check might involve converting both to numeric if possible or padding user input.
      # For now, direct check:
      if (!is.element(requested_res_char, available_resolutions_r)) {
        # Attempt to check if integer comparison works (e.g. user says 1, TF has "1")
        # Or if padded version works (user says 1, TF has "01")
        padded_requested_res <- sprintf("%02d", as.integer(requested_res_char))
        if (!(is.element(requested_res_char, available_resolutions_r) || 
             (suppressWarnings(!is.na(as.integer(requested_res_char))) && is.element(padded_requested_res, available_resolutions_r)) ) ) {
          stop(paste0("Resolution '", requested_res_char, "' not found for template space '", space, "'. \n",
                      "Available resolutions are: ", paste(available_resolutions_r, collapse=", "), "."))
        }
      }
    }
  }

  # Construct query parameters for Python API
  query_args <- list()

  # Handle resolution: TemplateFlow expects it as string, potentially with leading zero for <10.
  query_args$resolution <- sprintf("%02d", as.integer(resolution)) 
  # More robust way if TF handles numeric directly or expects string without padding:
  # query_args$resolution <- as.character(resolution) 
  # Check TF documentation for exact format (e.g. '1' vs '01')
  # For now, assuming TemplateFlow Python API handles string or numeric resolution consistently or we pass string.
  # Let's stick to string as per `templateflow.api.get` doc which uses strings for resolution.
  query_args$resolution <- as.character(resolution)

  # --- Parameter Validation (T2.1.3) --- 
  supported_variants <- c("brain", "head", "mask", "probseg", "dseg")
  if (!is.null(variant) && !(variant %in% supported_variants)) {
    warning(paste0("Unsupported 'variant': ", variant, ". It might not be used for inferring 'desc' or 'suffix'. Consider providing 'desc' and 'suffix' explicitly. Supported variants for inference: ", paste(supported_variants, collapse=", "), "."))
  }
  # Add more supported modalities if needed for inference logic
  supported_modalities <- c("T1w", "T2w", "mask") 
  if (!is.null(modality) && !(modality %in% supported_modalities)) {
    warning(paste0("Unsupported 'modality': ", modality, ". It might not be used for inferring 'suffix'. Consider providing 'suffix' explicitly. Supported modalities for inference: ", paste(supported_modalities, collapse=", "), "."))
  }

  # Prioritize explicit desc and suffix
  current_desc <- desc
  current_suffix <- suffix

  # Infer desc from variant if desc is not provided
  if (is.null(current_desc) && !is.null(variant)) {
    current_desc <- switch(variant,
      "brain" = "brain",
      "head" = "head",
      "mask" = "brain", 
      "probseg" = "probseg",
      "dseg" = "dseg",
      NULL 
    )
  }
  
  # Infer suffix from modality/variant if suffix is not provided
  if (is.null(current_suffix) && !is.null(modality)) {
    current_suffix <- switch(modality,
      "T1w" = "T1w",
      "T2w" = "T2w",
      "mask" = "mask", 
      NULL 
    )
  }
  if (is.null(current_suffix) && !is.null(variant)){
      current_suffix <- switch(variant,
          "probseg" = "probseg", # Suffix often same as desc for these
          "dseg" = "dseg",
          "mask" = "mask", # If modality didn't set it as mask
          NULL
      )
  }

  # Validation Check 1: Essential desc and suffix after inference
  final_desc_to_use <- ifelse(!is.null(desc), desc, current_desc)
  final_suffix_to_use <- ifelse(!is.null(suffix), suffix, current_suffix)

  if (is.null(final_desc_to_use)) {
    stop("Could not determine 'desc' parameter. Provide 'desc' explicitly or use a supported 'variant' for inference: ", paste(supported_variants, collapse=", "))
  }
  if (is.null(final_suffix_to_use)) {
    stop("Could not determine 'suffix' parameter. Provide 'suffix' explicitly or use a supported 'variant'/'modality' for inference: ", paste(c(supported_variants, supported_modalities), collapse=", "))
  }

  # Validation Check 2: Label consistency
  if (!is.null(label)) {
    expected_descs_for_label <- c("probseg", "dseg")
    if (!(final_desc_to_use %in% expected_descs_for_label)) {
      warning(paste0("'label' parameter is typically used when 'desc' is one of '", 
                     paste(expected_descs_for_label, collapse="', '"), 
                     "'. Current effective 'desc' is '", final_desc_to_use, "'."))
    }
  }

  # Validation Check 3: variant="mask" consistency
  if (!is.null(variant) && variant == "mask") {
    if (final_suffix_to_use != "mask") {
      warning(paste0("For 'variant = \"mask\"', the typical 'suffix' is \"mask\". ",
                     "Current effective 'suffix' is '", final_suffix_to_use, "'. The result may not be a standard mask file."))
    }
    # Also, for variant="mask", desc is often "brain" or just "mask". 
    # Current inference sets current_desc to "brain" for variant="mask". This is generally fine.
    # If desc was explicitly provided as something else, that takes precedence.
  }

  query_args$desc <- final_desc_to_use
  query_args$suffix <- final_suffix_to_use

  # Add other direct pass-through parameters if not NULL
  if (!is.null(space)) query_args$template <- space # Python API uses 'template' for space ID
  if (!is.null(label)) query_args$label <- label
  if (!is.null(atlas)) query_args$atlas <- atlas
  if (!is.null(cohort)) query_args$cohort <- cohort
  if (!is.null(extension)) query_args$extension <- extension

  # Combine with any additional arguments from ...
  # Ensure ... args don't overwrite explicitly set ones (though tf$api$get might handle this)
  additional_args <- list(...)
  for (arg_name in names(additional_args)) {
    query_args[[arg_name]] <- additional_args[[arg_name]]
  }
  
  # Remove NULLs from query_args before calling, as python function might not like None for all args
  query_args <- Filter(Negate(is.null), query_args)

  # Sort query_args by name to ensure canonical form for memoisation key
  if (length(query_args) > 0) {
    query_args <- query_args[sort(names(query_args))]
  }

  # Call the memoised function to fetch the template path
  file_path_r_string <- tryCatch({
    .memoised_fetch_templateflow_path(tf_api_obj = tf$api, query_params_list = query_args)
  }, templateflow_api_error = function(e) {
    # Stop with the message from the custom error object
    stop(conditionMessage(e))
  }, templateflow_no_files_error = function(e) {
    stop(conditionMessage(e))
  }, templateflow_processing_error = function(e) {
    stop(conditionMessage(e))
  }, templateflow_conversion_error = function(e) {
    stop(conditionMessage(e))
  }, error = function(e) {
    # Catch any other unexpected errors during the call
    stop(paste0("An unexpected error occurred while trying to fetch from TemplateFlow: ", conditionMessage(e)))
  })
  
  # file_path_r_string now holds the path (from cache or fresh query)
  # The original logic for handling py_result_path being NULL or a list is now inside .perform_tf_get_and_convert_to_path

  if (path_only) {
    return(file_path_r_string)
  } else {
    # Convert to NeuroVol using the helper
    return(as_neurovol(file_path_r_string)) # as_neurovol can also take py_result_path directly
  }
}

#' Internal Helper to Convert Python Object/Path to NeuroVol
#'
#' This function takes a file path (string) or a Python object that can be resolved
#' to a NIfTI file path (e.g., a Python Path object from TemplateFlow) and reads it
#' into a \code{neuroim2::NeuroVol} object.
#'
#' @param path_or_py_obj A file path string or a Python object (e.g., \code{pathlib.Path}).
#' @return A \code{neuroim2::NeuroVol} object.
#' @importFrom neuroim2 read_vol
#' @importFrom reticulate py_to_r
#' @keywords internal
.as_neurovol_unmemoised <- function(path_or_py_obj) {
  file_path <- NULL
  if (is.character(path_or_py_obj)) {
    file_path <- path_or_py_obj
  } else if (reticulate::is_py_object(path_or_py_obj) && reticulate::py_has_attr(path_or_py_obj, "as_posix")) {
    # Assuming it's a pathlib.Path-like object from templateflow's get()
    file_path <- reticulate::py_to_r(path_or_py_obj$as_posix())
  } else if (reticulate::is_py_object(path_or_py_obj)){
    # Fallback for other Python objects that might be string paths
    file_path <- tryCatch(reticulate::py_to_r(path_or_py_obj), error = function(e) NULL)
    if (!is.character(file_path)){
        stop("Input 'path_or_py_obj' is a Python object but could not be converted to a file path string.")
    }
  } else {
    stop("Input 'path_or_py_obj' must be a file path string or a suitable Python object.")
  }

  if (!file.exists(file_path)) {
    stop("Resolved file path does not exist: ", file_path)
  }
  
  # Read the NIfTI file using neuroim2::read_vol
  vol <- tryCatch({
    neuroim2::read_vol(file_path)
  }, error = function(e) {
    stop("Failed to read NIfTI file (", file_path, ") into NeuroVol: ", e$message)
  })
  
  return(vol)
}

#' Memoised version of .as_neurovol_unmemoised
#' This is the function that should be called by get_template
#' @keywords internal
as_neurovol <- memoise::memoise(.as_neurovol_unmemoised)

#' Access Templateflow Brain Templates (DEPRECATED)
#'
#' @description
#' [DEPRECATED] This function signature is deprecated. Please use the new 
#' \code{\link{get_template}} function (defined earlier in this file) which offers 
#' a more comprehensive and R-native interface. The new function handles common 
#' variants and modalities more directly.
#'
#' @param name Character string specifying template name. Default: "MNI152NLin2009cAsym"
#' @param desc Character string describing template variant. Default: "brain"
#' @param resolution Numeric resolution in mm. Default: 1
#' @param label Character string specifying tissue label for probability maps
#' @param atlas Character string specifying atlas name
#' @param suffix Character string specifying image type. Default: "T1w"
#' @param extension Character string specifying file extension. Default: ".nii.gz"
#'
#' @return A NeuroVol object containing the requested template
#'
#' @seealso The new \code{\link{get_template}} (defined with an updated signature).
#' @md
#' @deprecate new="get_template" msg="This specific signature of get_template() is deprecated. Please use the newer get_template() function (defined with parameters like `space`, `variant`, `modality`) for a more streamlined interface."
#' @keywords internal
#' @export
get_template <- function(name="MNI152NLin2009cAsym", desc="brain", resolution=1, 
                        label=NULL, atlas=NULL, suffix="T1w", 
                        extension=".nii.gz") {
  # T8.1.3: Add lifecycle deprecation warning
  lifecycle::deprecate_warn(
    when = "0.10.0", # Replace with actual version when this is released
    what = "get_template(name)",
    with = "get_template(space)",
    details = paste0(
      "The signature get_template(name, desc, resolution, ...) is deprecated.\n",
      "Please use the new signature: get_template(space, variant, modality, resolution, ...), where 'space' replaces 'name'."
    )
  )
  
  # Note: The function signature above is the OLD one.
  # We are calling the NEW get_template() which is defined *earlier* in this file.
  # Need to ensure `neuroatlas::` is not strictly necessary if this file is sourced in order,
  # but explicit call can be safer during refactoring if file is split or order changes.
  # For now, direct call as it *should* resolve to the newer one due to R's environment lookup.
  
  # The new get_template will use explicit desc/suffix if provided, 
  # overriding variant/modality inference from its own defaults.
  neuroatlas::get_template(space = name, 
                           desc = desc, 
                           resolution = resolution, 
                           label = label, 
                           atlas = atlas, 
                           suffix = suffix, 
                           extension = extension,
                           # Pass through other defaults from the new get_template explicitly if needed,
                           # or rely on the new get_template's defaults for variant, modality etc.
                           # when desc/suffix are specific enough.
                           variant = NULL, # Explicitly NULL so new get_template doesn't use its default variant logic if desc is set
                           modality = NULL # Explicitly NULL so new get_template doesn't use its default modality logic if suffix is set
                           )
}

#' Get Brain Mask from Template (DEPRECATED)
#'
#' @description
#' [DEPRECATED] Please use \code{\link{get_template}(variant = "mask", ...)} instead.
#'
#' Convenience function to retrieve a binary brain mask for a specified template.
#'
#' @param name Character string specifying template name. Default: "MNI152NLin2009cAsym"
#' @param resolution Numeric resolution in mm. Default: 1
#' @param extension Character string specifying file extension. Default: ".nii.gz"
#' @return A NeuroVol object containing the binary brain mask
#' @seealso The new \code{\link{get_template}}
#' @md
#' @deprecate new="get_template" msg="get_template_brainmask() is deprecated. Use get_template(variant = \"mask\") instead."
#' @keywords internal
#' @export
get_template_brainmask <- function(name="MNI152NLin2009cAsym", resolution=1, 
                                  extension=".nii.gz") {
  lifecycle::deprecate_warn(
    when = "0.10.0", 
    what = "get_template_brainmask()",
    with = "get_template(variant = \"mask\")"
  )
  neuroatlas::get_template(space = name, variant = "mask", resolution = resolution, 
                           extension = extension)
}

#' Get Tissue Probability Map from Template (DEPRECATED)
#'
#' @description
#' [DEPRECATED] Please use \code{\link{get_template}(variant = "probseg", label = ..., ...)} instead.
#'
#' Retrieves probability maps for different tissue types (GM, WM, CSF).
#'
#' @inheritParams get_template_brainmask
#' @param label Character string specifying tissue type ("GM", "WM", or "CSF"). Default: "GM"
#' @return A NeuroVol object containing the probability map
#' @seealso The new \code{\link{get_template}}
#' @md
#' @deprecate new="get_template" msg="get_template_probseg() is deprecated. Use get_template(variant = \"probseg\", label = <tissue>) instead."
#' @keywords internal
#' @export
get_template_probseg <- function(name="MNI152NLin2009cAsym", label="GM", 
                                resolution=1, extension=".nii.gz") {
  lifecycle::deprecate_warn(
    when = "0.10.0", 
    what = "get_template_probseg()",
    with = "get_template(variant = \"probseg\", label = ...)"
  )
  neuroatlas::get_template(space = name, variant = "probseg", label = label, 
                           resolution = resolution, extension = extension)
}

#' Get Schaefer Parcellation in Template Space (DEPRECATED)
#'
#' @description
#' [DEPRECATED] Please use \code{\link{get_template}(atlas = "Schaefer2018", desc = ..., suffix = "dseg", ...)} instead.
#'
#' Retrieves Schaefer cortical parcellation mapped to a specified template space.
#'
#' @inheritParams get_template_brainmask
#' @param parcels Number of parcels (400 default)
#' @param networks Number of networks (17 default)
#' @return A NeuroVol object containing the parcellation
#' @seealso The new \code{\link{get_template}}
#' @md
#' @deprecate new="get_template" msg="get_template_schaefer() is deprecated. Use get_template(atlas = \"Schaefer2018\", desc = <parcelsNetworks>, suffix = \"dseg\") instead."
#' @keywords internal
#' @export
get_template_schaefer <- function(name="MNI152NLin2009cAsym", resolution=1,
                                 parcels=400, networks=17, extension=".nii.gz") {
  lifecycle::deprecate_warn(
    when = "0.10.0", 
    what = "get_template_schaefer()",
    with = "get_template(atlas = \"Schaefer2018\", ...)"
  )
  desc_str <- paste0(parcels, "Parcels", networks, "Networks")
  neuroatlas::get_template(space = name, desc = desc_str, atlas = "Schaefer2018", 
                           suffix = "dseg", resolution = resolution, extension = extension)
}

#' List Available Templates
#'
#' @description
#' Returns a list of all available templates in the Templateflow repository.
#'
#' @return A character vector of available template names
#' @export
#' @deprecate fun="templates" new="tflow_spaces" msg="The `templates()` function is deprecated. Please use `tflow_spaces()` instead for a more consistent naming scheme."
#' @keywords internal
templates <- function() {
  lifecycle::deprecate_warn(
    when = "0.10.0",
    what = "templates()",
    with = "tflow_spaces()"
  )
  # Ensure .tflow_env$py_api is initialized if this is called directly
  if (is.null(.tflow_env$py_api)) {
    create_templateflow() # Initialize if not already
  }
  if (is.null(.tflow_env$py_api)) { # Still NULL after trying
      warning("TemplateFlow API not available. Cannot list templates.")
      return(character(0))
  }
  .tflow_env$py_api$templates()
}

#' Get Template Head Image (DEPRECATED)
#'
#' @description
#' [DEPRECATED] Please use \code{\link{get_template}(variant = "head", ...)} instead.
#'
#' Convenience function to get the full head (non-brain-extracted) template.
#'
#' @inheritParams get_template_brainmask
#' @return A NeuroVol object containing the head template
#' @seealso The new \code{\link{get_template}}
#' @md
#' @deprecate new="get_template" msg="get_template_head() is deprecated. Use get_template(variant = \"head\") instead."
#' @keywords internal
#' @export
get_template_head <- function(name="MNI152NLin2009cAsym", resolution=1, 
                            extension=".nii.gz") {
  lifecycle::deprecate_warn(
    when = "0.10.0", 
    what = "get_template_head()",
    with = "get_template(variant = \"head\")"
  )
  neuroatlas::get_template(space = name, variant = "head", resolution = resolution, 
                           extension = extension)
}

#' Get CSF Probability Map (DEPRECATED)
#'
#' @description
#' [DEPRECATED] Please use \code{\link{get_template}(variant = "probseg", label = "CSF", ...)} instead.
#'
#' Convenience function to get CSF probability map.
#'
#' @inheritParams get_template_brainmask
#' @return A NeuroVol object containing the CSF probability map
#' @seealso The new \code{\link{get_template}}
#' @md
#' @deprecate new="get_template" msg="get_template_csf() is deprecated. Use get_template(variant = \"probseg\", label = \"CSF\") instead."
#' @keywords internal
#' @export
get_template_csf <- function(name="MNI152NLin2009cAsym", resolution=1, 
                            extension=".nii.gz") {
  lifecycle::deprecate_warn(
    when = "0.10.0", 
    what = "get_template_csf()",
    with = "get_template(variant = \"probseg\", label = \"CSF\")"
  )
  neuroatlas::get_template(space = name, variant = "probseg", label = "CSF", 
                           resolution = resolution, extension = extension)
}

#' Get Gray Matter Probability Map (DEPRECATED)
#'
#' @description
#' [DEPRECATED] Please use \code{\link{get_template}(variant = "probseg", label = "GM", ...)} instead.
#'
#' Convenience function to get gray matter probability map.
#'
#' @inheritParams get_template_brainmask
#' @return A NeuroVol object containing the gray matter probability map
#' @seealso The new \code{\link{get_template}}
#' @md
#' @deprecate new="get_template" msg="get_template_gm() is deprecated. Use get_template(variant = \"probseg\", label = \"GM\") instead."
#' @keywords internal
#' @export
get_template_gm <- function(name="MNI152NLin2009cAsym", resolution=1, 
                           extension=".nii.gz") {
  lifecycle::deprecate_warn(
    when = "0.10.0", 
    what = "get_template_gm()",
    with = "get_template(variant = \"probseg\", label = \"GM\")"
  )
  neuroatlas::get_template(space = name, variant = "probseg", label = "GM", 
                           resolution = resolution, extension = extension)
}

#' Get White Matter Probability Map (DEPRECATED)
#'
#' @description
#' [DEPRECATED] Please use \code{\link{get_template}(variant = "probseg", label = "WM", ...)} instead.
#'
#' Convenience function to get white matter probability map.
#'
#' @inheritParams get_template_brainmask
#' @return A NeuroVol object containing the white matter probability map
#' @seealso The new \code{\link{get_template}}
#' @md
#' @deprecate new="get_template" msg="get_template_wm() is deprecated. Use get_template(variant = \"probseg\", label = \"WM\") instead."
#' @keywords internal
#' @export
get_template_wm <- function(name="MNI152NLin2009cAsym", resolution=1, 
                           extension=".nii.gz") {
  lifecycle::deprecate_warn(
    when = "0.10.0", 
    what = "get_template_wm()",
    with = "get_template(variant = \"probseg\", label = \"WM\")"
  )
  neuroatlas::get_template(space = name, variant = "probseg", label = "WM", 
                           resolution = resolution, extension = extension)
}

# Typed Helper Functions for TemplateFlow

#' @rdname get_template
#' @param template_id The main TemplateFlow template identifier for the surface
#'        (e.g., "fsLR", "fsaverage"). This is passed as the `space` argument to `get_template`.
#' @param surface_type A character string indicating the type of surface to retrieve.
#'        Common values include: "pial", "white", "inflated", "midthickness", "sphere".
#'        This is passed as the `desc` argument to `get_template`.
#' @param hemi Character string, "L" for left hemisphere or "R" for right hemisphere.
#'        Passed as `hemi` to `get_template`.
#' @param density (Optional) Character string specifying the surface density
#'        (e.g., "32k" for fsLR, "164k" for fsaverage). Passed as `den` to `get_template`.
#' @param resolution (Optional) Character string specifying the resolution, primarily for
#'        fsaverage variants (e.g., "06" for fsaverage6, which is `tpl-fsaverage_res-06...`).
#'        Passed as `resolution` to `get_template`.
#' @param load_as_path Logical, whether to return only the path to the file.
#'        Defaults to `TRUE` as `NeuroVol` objects are not typically used for surface geometry.
#'        If `FALSE`, attempts to load using `as_neurovol` (via `get_template`).
#' @return If `load_as_path` is `TRUE`, a character string (path) or a list of character strings (paths).
#'         If `load_as_path` is `FALSE`, the result of `as_neurovol` (which might be a `NeuroVol`
#'         if `neuroim2::read_vol` supports the format, or could error if not).
#'         Returns `NULL` if no template is found.
#' @export
#' @examples
#' \donttest{
#'   # Get the pial surface for the left hemisphere of fsLR 32k template (as path)
#'   # fslr_pial_L_path <- get_surface_template(template_id = "fsLR", surface_type = "pial",
#'   #                                        hemi = "L", density = "32k")
#'   # print(fslr_pial_L_path)
#'
#'   # Get the white surface for fsaverage6 (res="06", den="41k") right hemisphere
#'   # fsaverage6_white_R_path <- get_surface_template(template_id = "fsaverage",
#'   #                                               surface_type = "white",
#'   #                                               hemi = "R",
#'   #                                               resolution = "06", # for fsaverage6
#'   #                                               density = "41k")   # for fsaverage6
#'   # print(fsaverage6_white_R_path)
#' }
get_surface_template <- function(template_id, surface_type, hemi,
                                 density = NULL, resolution = NULL,
                                 ...,
                                 load_as_path = TRUE) {

  if (!is.character(template_id) || length(template_id) != 1) {
    stop("'template_id' must be a single character string.")
  }
  if (!is.character(surface_type) || length(surface_type) != 1) {
    stop("'surface_type' must be a single character string.")
  }
  if (!hemi %in% c("L", "R")) {
    stop("'hemi' must be either 'L' or 'R'.")
  }

  # Construct the call to the main get_template function
  # We pass hemi, den (from density), and other ... args directly.
  # resolution is also a direct pass-through for get_template.
  call_args <- list(
    space = template_id,
    desc = surface_type,
    suffix = "surf",        # Common suffix for surface geometry files
    extension = ".gii",     # Common extension for Gifti surface files
    resolution = resolution,
    load_as_neurovol = !load_as_path,
    hemi = hemi
    # den will be added from density if not NULL
  )

  if (!is.null(density)) {
    call_args$den <- density
  }
  
  # Combine with other arguments from ...
  # utils::modifyList will give precedence to arguments in the first list (call_args)
  # if there are any name clashes with ellipsis_args. We want ellipsis_args to add new ones.
  ellipsis_args <- list(...)
  final_args <- utils::modifyList(ellipsis_args, call_args) # puts call_args last, so it overwrites
  # we want ellipsis to be able to override if user passes e.g. suffix explicitly
  # so, the order in modifyList matters. The second list's values take precedence for shared names.
  # Let's ensure explicit params here take precedence over ellipsis, then add non-conflicting ellipsis.
  
  # Start with our fixed/derived args
  base_call_args <- list(
    space = template_id,
    desc = surface_type,
    suffix = "surf",
    extension = ".gii",
    load_as_neurovol = !load_as_path,
    hemi = hemi
  )
  
  # Add resolution if provided (it's a named param in get_template)
  if (!is.null(resolution)) {
    base_call_args$resolution <- resolution
  }
  
  # Add density as 'den' (this goes into ... of get_template)
  additional_tf_params <- list()
  if (!is.null(density)) {
    additional_tf_params$den <- density
  }
  
  # Combine ... from this function call with our derived additional_tf_params
  # an argument explicitly in ... will override one from additional_tf_params if names clash
  final_ellipsis_args <- utils::modifyList(additional_tf_params, ellipsis_args)
  
  # Now combine base_call_args with the final_ellipsis_args
  # Explicit arguments in base_call_args should not be overwritten by final_ellipsis_args
  # So, we add final_ellipsis_args to base_call_args, but only if name not already in base_call_args
  for (arg_name in names(final_ellipsis_args)) {
      if (!arg_name %in% names(base_call_args)) {
          base_call_args[[arg_name]] <- final_ellipsis_args[[arg_name]]
      } else {
          # Potentially warn if ... tries to override a core derived parameter like desc, suffix, etc.
          # For now, we assume user knows what they are doing if they pass e.g. desc in ...
          # However, the new get_template structure with explicit variant/modality handles this better.
          # Here, we let ... override for things like 'den' but not core structure.
          # The most robust is just to pass all ... directly to get_template and let it manage.
          # The current structure of get_template is: named args, then ...
          # So, `den` should be passed via `...` to get_surface_template and then to get_template.
      }
  }

  # Simpler: construct arguments for do.call ensuring 'den' and other ... are correctly passed
  final_args_for_get_template <- list(
    space = template_id,
    desc = surface_type,
    suffix = "surf",
    extension = ".gii",
    resolution = resolution, # Explicitly pass, even if NULL, get_template handles it
    load_as_neurovol = !load_as_path,
    hemi = hemi
  )
  if (!is.null(density)) {
    final_args_for_get_template$den <- density # Add 'den' if density is provided
  }
  
  # Merge with any other ... arguments passed to get_surface_template
  # Arguments in final_args_for_get_template take precedence over those in list(...)
  # if there are name clashes, which is desired for core parameters. 
  # For new parameters from ..., they will be added.
  combined_args <- utils::modifyList(list(...), final_args_for_get_template)

  do.call(get_template, combined_args)
}

# Cache Management Functions ----

#' Clear neuroatlas TemplateFlow Cache
#'
#' Removes all files and subdirectories from the `neuroatlas` package's cache 
#' directory used for TemplateFlow downloads. This function also clears the 
#' in-memory memoisation cache for TemplateFlow path lookups.
#' 
#' The TemplateFlow cache directory is typically located within the path returned by
#' `tools::R_user_dir("neuroatlas", "cache")`, in a subdirectory named "templateflow".
#' 
#' @param confirm Logical. If `TRUE` (the default), the function will ask for 
#'   interactive confirmation before deleting files if the session is interactive.
#'   If `FALSE`, or if the session is not interactive, deletion will proceed without confirmation.
#' @return Invisibly returns `TRUE` if the cache was cleared or attempted to be cleared,
#'   and `FALSE` if the operation was aborted by the user during confirmation.
#' @export
#' @examples
#' \dontrun{
#'   # Clear the TemplateFlow cache (will ask for confirmation if interactive)
#'   # clear_templateflow_cache()
#'   
#'   # Clear without confirmation
#'   # clear_templateflow_cache(confirm = FALSE)
#' }
clear_templateflow_cache <- function(confirm = TRUE) {
  tf_cache_dir <- .neuroatlas_cache_dir("templateflow")
  
  proceed <- FALSE
  if (interactive() && confirm) {
    response <- utils::askYesNo(
      paste0("Are you sure you want to delete all files in the neuroatlas TemplateFlow cache (", 
             tf_cache_dir, ") and clear the memoisation cache?"),
      default = FALSE
    )
    if (!is.na(response) && response) {
      proceed <- TRUE
    }
  } else {
    proceed <- TRUE # Non-interactive or confirm=FALSE
  }
  
  if (!proceed) {
    message("Cache clearing aborted by user.")
    return(invisible(FALSE))
  }
  
  if (dir.exists(tf_cache_dir)) {
    message("Deleting contents of: ", tf_cache_dir)
    # List all files and directories, including hidden ones, but not . and ..
    items_to_delete <- list.files(tf_cache_dir, all.files = TRUE, no.. = TRUE, full.names = TRUE)
    if (length(items_to_delete) > 0) {
      unlink(items_to_delete, recursive = TRUE, force = TRUE)
      message("Successfully deleted items from disk cache.")
    } else {
      message("Disk cache directory was empty.")
    }
  } else {
    message("Cache directory not found (already clear or never created): ", tf_cache_dir)
  }
  
  # Clear the memoise cache for the specific function
  if (exists(".memoised_fetch_templateflow_path", where = globalenv()) || 
      exists(".memoised_fetch_templateflow_path", where = asNamespace("neuroatlas"))) {
    tryCatch({
      memoise::forget(.memoised_fetch_templateflow_path)
      message("Successfully cleared in-memory memoisation cache for TemplateFlow paths.")
    }, error = function(e) {
      warning("Could not clear memoisation cache: ", e$message)
    })
  } else {
    message("Memoised function not found; skipping memoisation cache clearing.")
  }
  
  invisible(TRUE)
}

#' Show neuroatlas TemplateFlow Cache Path
#'
#' Returns the path to the `neuroatlas` package's cache directory used for 
#' TemplateFlow downloads. This is typically located within the path returned by
#' `tools::R_user_dir("neuroatlas", "cache")`, in a subdirectory named "templateflow".
#'
#' @return A character string representing the path to the TemplateFlow cache directory.
#' @export
#' @examples
#' cat("TemplateFlow cache is at:", show_templateflow_cache_path(), "\n")
show_templateflow_cache_path <- function() {
  .neuroatlas_cache_dir("templateflow")
}

# Discoverability Functions ----

#' List Available TemplateFlow Template Spaces
#'
#' Retrieves a list of all available template space identifiers from the TemplateFlow archive.
#' These identifiers are top-level names like "MNI152NLin2009cAsym", "fsLR", etc.
#'
#' @param pattern (Optional) A character string containing a regular expression 
#'   to filter the template space names. If `NULL` (default), all names are returned.
#' @param api_handle (Optional) An existing `templateflow` S3 object created by 
#'   `create_templateflow()`. If `NULL`, a default one will be initialized.
#' @param ... Additional arguments passed to `grep` if `pattern` is specified 
#'   (e.g., `ignore.case = TRUE`).
#' @return A character vector of available template space names. Returns `NULL` if the 
#'   list cannot be retrieved, with a warning.
#' @export
#' @examples
#' \donttest{
#'   # List all template spaces
#'   # all_spaces <- tflow_spaces()
#'   # print(head(all_spaces))
#'   
#'   # List template spaces containing "MNI"
#'   # mni_spaces <- tflow_spaces(pattern = "MNI")
#'   # print(mni_spaces)
#' }
tflow_spaces <- function(pattern = NULL, api_handle = NULL, ...) {
  if (is.null(api_handle)) {
    tf <- create_templateflow() 
  } else {
    if (!inherits(api_handle, "templateflow")) {
      stop("'api_handle' must be an object of class 'templateflow' from create_templateflow().")
    }
    tf <- api_handle
  }

  if (is.null(tf$api)) {
    warning("TemplateFlow API handle is not initialized. Cannot list template spaces.")
    return(NULL)
  }

  available_templates_py <- NULL
  tryCatch({
    available_templates_py <- tf$api$templates()
  }, error = function(e) {
    warning(paste0("Could not retrieve list of available TemplateFlow template spaces: ", e$message))
    return(NULL)
  })
  
  if (is.null(available_templates_py)) {
    # Should have been caught by tryCatch, but as a safeguard
    return(NULL) 
  }
  
  available_templates_r <- reticulate::py_to_r(available_templates_py)
  
  if (!is.null(pattern)) {
    if (!is.character(pattern) || length(pattern) != 1) {
      stop("'pattern' must be a single character string (regular expression).")
    }
    available_templates_r <- grep(pattern, available_templates_r, value = TRUE, ...)
  }
  
  return(available_templates_r)
}

#' Find TemplateFlow Files Matching Metadata Criteria
#'
#' Retrieves a list of file paths from TemplateFlow that match a given template 
#' space and other optional metadata query parameters.
#' This function calls the Python `templateflow.api.get()` method with 
#' `raise_on_empty=FALSE` to get a list of all matching files.
#'
#' @param space Character string. The primary TemplateFlow identifier for the template 
#'   space (e.g., "MNI152NLin2009cAsym"). This is passed as `template` to the Python API.
#' @param query_args (Optional) A named list of additional query parameters to 
#'   filter the results (e.g., `list(suffix = "T1w", resolution = "1", desc = "brain")`).
#'   These are passed directly as keyword arguments to the Python `templateflow.api.get()`.
#' @param api_handle (Optional) An existing `templateflow` S3 object created by 
#'   `create_templateflow()`. If `NULL`, a default one will be initialized.
#' @return A character vector of file paths matching the query. Returns an empty 
#'   vector if no files match, or `NULL` with a warning if the API call fails.
#' @export
#' @examples
#' \donttest{
#'   # List all T1w files for MNI152NLin2009cAsym template
#'   # mni_t1w_files <- tflow_files("MNI152NLin2009cAsym", 
#'   #                                           query_args = list(suffix = "T1w"))
#'   # print(mni_t1w_files)
#'   
#'   # List all files for the OASIS30ANTs template with desc "brain"
#'   # oasis_brains <- tflow_files("OASIS30ANTs", 
#'   #                                           query_args = list(desc = "brain"))
#'   # print(oasis_brains)
#' }
tflow_files <- function(space, query_args = list(), api_handle = NULL) {
  if (is.null(api_handle)) {
    tf <- create_templateflow() 
  } else {
    if (!inherits(api_handle, "templateflow")) {
      stop("'api_handle' must be an object of class 'templateflow' from create_templateflow().")
    }
    tf <- api_handle
  }

  if (is.null(tf$api)) {
    warning("TemplateFlow API handle is not initialized. Cannot list metadata.")
    return(NULL)
  }
  
  if (!is.character(space) || length(space) != 1) {
    stop("'space' must be a single character string.")
  }
  if (!is.list(query_args)) {
    stop("'query_args' must be a list.")
  }

  # Construct the full query for the Python API
  full_python_query <- query_args
  full_python_query$template <- space
  full_python_query$raise_on_empty <- FALSE # Ensure it returns list, not error on empty
  
  # Ensure query args are sorted for potential future memoisation consistency if applied here
  if (length(full_python_query) > 0) {
      full_python_query <- full_python_query[sort(names(full_python_query))]
  }

  py_path_list_obj <- NULL
  tryCatch({
    py_path_list_obj <- do.call(tf$api$get, full_python_query)
  }, error = function(e) {
    warning(paste0("TemplateFlow API error while listing metadata: ", e$message,
                   "\nQuery: template=", space, ", args=", paste(names(query_args), query_args, sep="=", collapse=", ")))
    return(NULL) # Return NULL on API error
  })

  if (is.null(py_path_list_obj)) {
    # This can happen if the API call itself failed and returned NULL from tryCatch
    return(NULL) 
  }
  
  # Convert Python list of Path objects to R character vector of paths
  r_paths <- character(0)
  if (reticulate::is_py_object(py_path_list_obj) && inherits(py_path_list_obj, "python.builtin.list")) {
    if (length(py_path_list_obj) > 0) {
      r_paths <- sapply(py_path_list_obj, function(py_path) {
        tryCatch(reticulate::py_to_r(py_path$as_posix()), error = function(e) NA_character_)
      })
      r_paths <- r_paths[!is.na(r_paths)] # Remove any that failed conversion
    }
    # If length is 0, r_paths remains character(0), which is correct for no matches
  } else if (reticulate::is_py_object(py_path_list_obj)) {
    # If TF returns a single Path object when only one file matches (even with raise_on_empty=F)
    # This is unlikely given raise_on_empty=F usually ensures a list, but handle defensively.
    single_path <- tryCatch(reticulate::py_to_r(py_path_list_obj$as_posix()), error = function(e) NA_character_)
    if (!is.na(single_path)) r_paths <- single_path
  } 
  # Else: py_path_list_obj might be something unexpected, r_paths remains empty. 
  # Or if TemplateFlow returns R NULL directly for no matches (unlikely with python object)  

  return(r_paths)
}

# Inter-package Integration Helpers ----

#' Resolve Template Input to NeuroVol or NeuroSpace
#'
#' This internal helper function takes a flexible input representing a neuroimaging
#' template and resolves it to either a `neuroim2::NeuroVol` object or a 
#' `neuroim2::NeuroSpace` object, typically by fetching it via `get_template()`
#' if it's not already in the desired R object form.
#'
#' @param input The input to resolve. Can be:
#'   - A `neuroim2::NeuroVol` object.
#'   - A `neuroim2::NeuroSpace` object.
#'   - A character string: Assumed to be a TemplateFlow `space` identifier. 
#'     `get_template()` will be called with this space and default values for 
#'     other parameters (e.g., `variant="brain"`, `resolution="1"`).
#'   - A named list: Assumed to be arguments for `get_template()`.
#'     `do.call(get_template, input)` will be used.
#' @param target_type A character string, either "NeuroVol" (default) or "NeuroSpace",
#'   specifying the desired output type.
#' @param api_handle (Optional) An existing `templateflow` S3 object.
#' @return An object of the `target_type`. If `target_type` is "NeuroSpace" and 
#'   a `NeuroVol` is obtained, its space is extracted via `neuroim2::space()`. 
#'   Returns `NULL` or stops on error if resolution fails.
#' @keywords internal
#' @importFrom neuroim2 is.NeuroVol is.NeuroSpace space
.resolve_template_input <- function(input, target_type = "NeuroVol", api_handle = NULL) {
  if (!target_type %in% c("NeuroVol", "NeuroSpace")) {
    stop("'target_type' must be either 'NeuroVol' or 'NeuroSpace'.")
  }

  resolved_vol <- NULL

  if (neuroim2::is.NeuroVol(input)) {
    resolved_vol <- input
  } else if (neuroim2::is.NeuroSpace(input)) {
    if (target_type == "NeuroSpace") {
      return(input) # Already correct type
    } else { # target_type == "NeuroVol"
      stop("Input is a NeuroSpace, but target_type is NeuroVol. Cannot convert NeuroSpace to NeuroVol without more information.")
    }
  } else if (is.character(input) && length(input) == 1) {
    # Assume string is a TemplateFlow space ID, use default params for get_template
    message("Resolving template input string '", input, "' as a TemplateFlow space ID with default parameters.")
    resolved_vol <- tryCatch({
      get_template(space = input, api_handle = api_handle) # Uses defaults of get_template
    }, error = function(e) {
      stop("Failed to resolve template string '", input, "' via get_template(): ", conditionMessage(e))
      return(NULL) # Should be caught by stop
    })
  } else if (is.list(input)) {
    # Assume list is arguments for get_template
    message("Resolving template input list via do.call(get_template, ...).")
    if (!is.null(api_handle)) {
      input$api_handle <- api_handle # Add api_handle if provided
    }
    resolved_vol <- tryCatch({
      do.call(get_template, input)
    }, error = function(e) {
      stop("Failed to resolve template list via get_template(): ", conditionMessage(e))
      return(NULL) # Should be caught by stop
    })
  } else {
    stop("Invalid 'input' type. Must be a NeuroVol, NeuroSpace, template name (string), or list of get_template() arguments.")
  }

  if (is.null(resolved_vol)) {
    # This case should ideally be handled by errors within the conditional blocks
    stop("Failed to obtain a NeuroVol from the provided input.")
  }
  
  if (!neuroim2::is.NeuroVol(resolved_vol)){
      stop("Resolution of input did not result in a NeuroVol object as expected.")
  }

  # Now, convert to target_type if necessary
  if (target_type == "NeuroVol") {
    return(resolved_vol)
  } else { # target_type == "NeuroSpace"
    return(neuroim2::space(resolved_vol))
  }
}

# Typed Helper Functions for TemplateFlow
</file>

<file path="R/aseg_subcort.R">
#' Get the FreeSurfer Subcortical Atlas (ASEG)
#'
#' @description
#' Loads and returns the FreeSurfer subcortical segmentation (ASEG) atlas, which provides
#' probabilistic labels for key subcortical structures in the brain. The atlas includes
#' bilateral structures such as the thalamus, caudate, putamen, and limbic regions,
#' as well as midline structures like the brainstem.
#'
#' @details
#' The ASEG atlas is derived from FreeSurfer's automatic subcortical segmentation
#' algorithm and has been transformed into standard space. Each voxel contains an
#' integer ID corresponding to a specific anatomical structure. The atlas includes
#' major subcortical structures for both hemispheres:
#' \itemize{
#'   \item Bilateral deep gray structures (thalamus, caudate, putamen, pallidum)
#'   \item Limbic structures (hippocampus, amygdala)
#'   \item Ventral structures (nucleus accumbens, ventral diencephalon)
#'   \item Midline structures (brainstem)
#' }
#'
#' @param outspace Optional \code{NeuroSpace} object specifying the desired output space
#'   for resampling the atlas. If NULL (default), returns the atlas in its native space.
#'
#' @return A list with classes 'aseg' and 'atlas' containing:
#' \describe{
#'   \item{atlas}{A \code{NeuroVol} object containing the 3D volume of atlas labels}
#'   \item{cmap}{A data frame with RGB color specifications for each region}
#'   \item{ids}{Integer vector of region IDs present in the atlas}
#'   \item{labels}{Character vector of anatomical labels corresponding to each ID}
#'   \item{hemi}{Character vector indicating hemisphere ('left', 'right', or NA) for each region}
#' }
#'
#' @examples
#' \dontrun{
#' # Load the atlas in native space
#' aseg <- get_aseg_atlas()
#'
#' # View the available region labels
#' aseg$labels
#'
#' # Get the unique region IDs
#' aseg$ids
#' }
#'
#' @references
#' Fischl, B., et al. (2002). Whole brain segmentation: automated labeling of
#' neuroanatomical structures in the human brain. Neuron, 33(3), 341-355.
#'
#' @seealso
#' \code{\link{map_atlas}} for mapping values onto atlas regions
#' \code{\link{get_roi}} for extracting specific regions of interest
#'
#' @importFrom neuroim2 read_vol
#' @importFrom tibble tribble
#' @export
get_aseg_atlas <- function(outspace=NULL) {
  fname <- system.file("extdata/atlas_aparc_aseg_prob33.nii.gz", package="neuroatlas")
  atlas <- neuroim2::read_vol(fname)

  if (!is.null(outspace)) {
    atlas <- resample(atlas, outspace)
  }

  ids <- sort(unique(as.vector(atlas))[-1])
  labels <- c(
    "Thalamus",
    "Caudate",
    "Putamen",
    "Pallidum",
    "Brainstem",
    "Hippocampus",
    "Amygdala",
    "Accumbens",
    "VentralDC",
    "Thalamus",
    "Caudate",
    "Putamen",
    "Pallidum",
    "Hippocampus",
    "Amygdala",
    "Accumbens",
    "VentralDC")

  hemi=c(rep("left", 4), NA, rep("left", 3), rep("right", 8))
  cmap <- tibble::tribble(
    ~red, ~green, ~blue,
    0,   118, 14,
    122, 186, 220,
    236, 13,  176,
    12,  48,  255,
    119, 159, 176,
    220, 216, 20,
    220, 216, 20,
    255, 165, 0,
    165, 42,  42,
    0,   118, 14,
    122, 186, 220,
    236, 13,  176,
    13,  48,  255,
    220, 216, 20,
    103, 255, 255,
    255, 165, 0,
    165, 42,  42)

  ret <- list(
    atlas=atlas,
    cmap=cmap,
    ids=ids,
    labels=labels,
    hemi=hemi)

  class(ret) <- c("aseg", "atlas")
  ret
}
</file>

<file path="R/olsen_mtl.R">
#' Olsen Medial Temporal Lobe Atlas
#'
#' @description
#' A detailed parcellation atlas of the medial temporal lobe (MTL) regions,
#' including hippocampus and surrounding cortical areas, based on the work of
#' Rosanna Olsen and colleagues.
#'
#' @details
#' The atlas provides a detailed segmentation of MTL structures in MNI space at 1mm
#' resolution. It includes bilateral parcellation of:
#' \itemize{
#'   \item Hippocampal subfields
#'   \item Perirhinal cortex
#'   \item Entorhinal cortex
#'   \item Parahippocampal cortex
#' }
#'
#' @format A list with class 'atlas' containing:
#' \describe{
#'   \item{name}{Character string identifying the atlas}
#'   \item{atlas}{NeuroVol object containing the parcellation in 1mm MNI space}
#'   \item{labels}{Character vector of anatomical region labels}
#'   \item{orig_labels}{Full region labels including hemisphere information}
#'   \item{ids}{Integer vector of region IDs (1:16)}
#'   \item{hemi}{Character vector indicating hemisphere ('left' or 'right')}
#' }
#'
#' @source
#' Olsen, R. K., et al. (2013). The role of relational binding in item memory:
#' Evidence from face recognition in a case of developmental amnesia.
#' Journal of Neuroscience, 33(36), 14107-14111.
#'
#' @examples
#' \donttest{
#' # Load the atlas data
#' data(olsen_mtl)
#'
#' # View available regions
#' olsen_mtl$labels
#'
#' # Check distribution across hemispheres
#' table(olsen_mtl$hemi)
#' }
#'
#' @keywords datasets
"olsen_mtl"

#' Load Olsen MTL Atlas
#'
#' @description
#' Loads the Olsen medial temporal lobe atlas and optionally resamples it to a
#' different space.
#'
#' @param outspace Optional \code{NeuroSpace} object specifying desired output space.
#'   If NULL (default), returns atlas in native 1mm MNI space.
#'
#' @return A list with class 'atlas' containing the MTL parcellation
#'
#' @examples
#' \donttest{
#' # Load in native space
#' mtl <- get_olsen_mtl()
#'
#' # Load and resample to a different space
#' mtl_resampled <- get_olsen_mtl(outspace = my_space)
#' }
#'
#' @seealso
#' \code{\link{get_hipp_atlas}} for hippocampus-specific parcellation
#'
#' @export
get_olsen_mtl <- function(outspace=NULL) {
  data(olsen_mtl)
  if (is.null(outspace)) {
    olsen_mtl
  } else {
    atres <- resample(olsen_mtl$atlas, outspace)
    tmp <- olsen_mtl
    tmp$atlas <- atres
    tmp
  }
}

#' Extract Hippocampal Parcellation
#'
#' @description
#' Creates a hippocampus-specific atlas from the Olsen MTL atlas, with optional
#' anterior-posterior subdivisions.
#'
#' @details
#' This function extracts hippocampal regions from the full MTL atlas and can
#' subdivide them into anterior-posterior segments. The resulting atlas maintains
#' bilateral organization and can be used for targeted hippocampal analyses.
#'
#' @param outspace Optional \code{NeuroSpace} object for resampling
#' @param apsections Integer specifying number of anterior-posterior divisions.
#'   Default: 1 (no subdivision)
#'
#' @return A list with class c("hippocampus", "atlas") containing:
#' \describe{
#'   \item{name}{Character string "hippocampus"}
#'   \item{atlas}{NeuroVol object with hippocampal parcellation}
#'   \item{ids}{Integer vector of region IDs}
#'   \item{labels}{Character vector of region labels}
#'   \item{hemi}{Character vector of hemisphere designations}
#'   \item{cmap}{Matrix of RGB colors for visualization}
#'   \item{orig_labels}{Full labels including hemisphere information}
#' }
#'
#' @examples
#' \dontrun{
#' # Basic hippocampal atlas
#' hipp <- get_hipp_atlas()
#'
#' # With anterior-posterior subdivisions
#' hipp_ap <- get_hipp_atlas(apsections = 3)
#' }
#'
#' @importFrom neuroim2 index_to_coord
#' @export
get_hipp_atlas <- function(outspace=NULL, apsections=1) {
  # Load and potentially resample base atlas
  x <- if (is.null(outspace)) {
    data(olsen_mtl)
    olsen_mtl
  } else {
    data(olsen_mtl)
    atres <- resample(olsen_mtl$atlas, outspace)
    tmp <- olsen_mtl
    tmp$atlas <- atres
    tmp
  }

  # Extract hippocampal regions
  atlas <- x$atlas
  atlas[atlas %in% c(1,2,3,6,8,9,10,11,14,16)] <- 1
  atlas[!(atlas %in% c(1,2,3,6,8,9,10,11,14,16))] <- 0

  ind <- which(atlas > 0)
  grid <- neuroim2::index_to_coord(atlas, which(atlas > 0))

  # Create anterior-posterior subdivisions if requested
  if (apsections > 1) {
    qz <- cut(grid[,2], apsections)
    levels(qz) <- paste0(seq(1,apsections))
    for (lev in levels(qz)) {
      atlas[ind[qz == lev]] <- as.numeric(lev)
    }
    atlas[ind[grid[,1] > 0]] <- atlas[ind[grid[,1] > 0]] + apsections
  } else {
    atlas[ind[grid[,1] > 0]] <- 2
  }

  # Create return object
  ret <- list(
    name = "hippocampus",
    atlas = atlas,
    ids = seq(1, apsections*2),
    labels = c(paste0("hippocampus_", seq(1,apsections)),
              paste0("hippocampus_", seq(1,apsections))),
    hemi = c(rep("left", apsections), rep("right", apsections)),
    cmap = t(col2rgb(rainbow(apsections*2)))
  )

  ret$orig_labels <- paste0(ret$hemi, "_", ret$labels)
  class(ret) <- c("hippocampus", "atlas")
  ret
}
</file>

<file path="R/dilate_parcels.R">
#' Dilate Atlas Parcellation Boundaries
#'
#' @description
#' Expands the boundaries of brain atlas parcels by dilating them into adjacent
#' unassigned voxels within a specified mask. This is useful for filling small gaps
#' between parcels or extending parcels into neighboring regions.
#'
#' @details
#' The dilation process:
#' \itemize{
#'   \item Identifies unassigned voxels within the mask that are adjacent to existing parcels
#'   \item For each unassigned voxel, finds nearby assigned voxels within the specified radius
#'   \item Assigns the unassigned voxel to the nearest parcel
#'   \item Respects mask boundaries to prevent dilation into unwanted regions
#' }
#'
#' The function uses a k-d tree implementation (via rflann) for efficient nearest
#' neighbor searches in 3D space.
#'
#' @param atlas An object of class "atlas" containing the parcellation to be dilated
#' @param mask A binary mask (NeuroVol object) specifying valid voxels for dilation.
#'   Dilation will only occur within non-zero mask values.
#'   Can also be a character string representing a TemplateFlow space ID (e.g., "MNI152NLin2009cAsym"),
#'   in which case the corresponding standard brain mask will be fetched from TemplateFlow.
#'   Alternatively, can be a list of arguments to pass to `neuroatlas::get_template` to fetch a specific mask.
#' @param radius Numeric. The maximum distance (in voxels) to search for neighboring
#'   parcels when dilating. Default: 4
#' @param maxn Integer. Maximum number of neighboring voxels to consider when
#'   determining parcel assignment. Default: 50
#'
#' @return A \code{ClusteredNeuroVol} object containing the dilated parcellation.
#'   The object maintains the original label mappings but may include additional
#'   voxels in existing parcels.
#'
#' @examples
#' \dontrun{
#' # Load an atlas
#' atlas <- get_aseg_atlas()
#'
#' # Create a brain mask
#' mask <- create_brain_mask(atlas)
#'
#' # Dilate parcels by 4 voxels
#' dilated <- dilate_atlas(atlas, mask, radius = 4)
#'
#' # More conservative dilation with fewer neighbors
#' dilated_conservative <- dilate_atlas(atlas, mask, radius = 2, maxn = 20)
#' }
#'
#' @seealso
#' \code{\link{create_brain_mask}} for creating appropriate masks
#'
#' @references
#' The algorithm uses the FLANN library for efficient nearest neighbor searches:
#' Muja, M., & Lowe, D. G. (2014). Scalable nearest neighbor algorithms for high
#' dimensional data. IEEE Transactions on Pattern Analysis and Machine Intelligence,
#' 36(11), 2227-2240.
#'
#' @importFrom assertthat assert_that
#' @importFrom neuroim2 index_to_coord index_to_grid ClusteredNeuroVol
#' @importFrom rflann RadiusSearch
#' @export
dilate_atlas <- function(atlas, mask, radius = 4, maxn = 50) {
    # --- Resolve mask input --- 
    if (!inherits(mask, "NeuroVol")) {
        resolved_mask_arg <- NULL
        if (is.character(mask) && length(mask) == 1) {
            message("Interpreting 'mask' string \"", mask, "\" as a request for its standard brain mask from TemplateFlow.")
            # Prepare args for get_template to fetch the brain mask for the given space ID
            resolved_mask_arg <- list(space = mask, variant = "mask") 
        } else if (is.list(mask)) {
            message("Interpreting 'mask' list as TemplateFlow parameters.")
            resolved_mask_arg <- mask
        } else {
            stop("`mask` must be a NeuroVol object, a TemplateFlow space ID string, or a list of TemplateFlow parameters for get_template.")
        }

        mask <- tryCatch({
            # Ensure .resolve_template_input is accessible. If in same package, neuroatlas::: might not be needed
            # but for clarity during dev or if it's not exported, using it.
            # Assuming .resolve_template_input is available in the package's namespace.
            neuroatlas:::.resolve_template_input(resolved_mask_arg, target_type = "NeuroVol")
        }, error = function(e) {
            query_str <- paste(names(resolved_mask_arg), sapply(resolved_mask_arg, function(x) if(is.list(x)) "<list>" else as.character(x)), sep="=", collapse=", ")
            stop(paste0("Failed to resolve 'mask' (", query_str, ") to a NeuroVol via TemplateFlow: ", conditionMessage(e)))
        })
    }

    # Validate inputs
    assertthat::assert_that(inherits(atlas, "atlas"),
                            msg = "`atlas` arg must be an atlas")
    assertthat::assert_that(inherits(mask, "NeuroVol"), # This now checks the resolved mask
                            msg = "`mask` must be a NeuroVol object or a valid TemplateFlow specifier that resolves to one.")
    assertthat::assert_that(radius > 0,
                            msg = "`radius` must be positive")
    assertthat::assert_that(maxn > 0,
                            msg = "`maxn` must be positive")

    # Convert the atlas to a dense array
    atlas2 <- neuroim2::as.dense(atlas$atlas)

    # Identify the indices of labeled voxels and mask voxels
    atlas_idx <- which(atlas2 > 0)
    mask_idx <- which(as.logical(mask))
    diff_idx <- setdiff(mask_idx, atlas_idx)

    # Early return if there's nothing to dilate
    if (length(diff_idx) == 0) {
        return(atlas)
    }

    # Convert linear indices to coordinates
    cd_atlas <- neuroim2::index_to_coord(mask, atlas_idx)
    cd_diff <- neuroim2::index_to_coord(mask, diff_idx)

    # Perform neighbor search for unlabeled (diff) voxels within the specified radius
    ret <- rflann::RadiusSearch(cd_diff, cd_atlas, radius = radius, max_neighbour = maxn)

    # Indices of points that have any neighbors
    qlen <- sapply(ret$indices, length)
    valid_queries <- which(qlen > 0)
    if (length(valid_queries) == 0) {
        # No neighbors for unlabeled voxels, so no change
        return(atlas)
    }

    # Filter neighbor sets to only those with valid neighbors
    indset <- ret$indices[valid_queries]
    dset   <- ret$distances[valid_queries]

    # Prepare output: list form, then we rbind later
    out_list <- vector("list", length(valid_queries))

    # Grid (x,y,z) for the labeled vs unlabeled sets
    dims <- dim(atlas2)
    grid_atlas <- neuroim2::index_to_grid(mask, atlas_idx)
    grid_diff  <- neuroim2::index_to_grid(mask, diff_idx)

    # For each unlabeled voxel that has neighbors
    for (i in seq_along(valid_queries)) {
        voxel_idx <- valid_queries[i]
        neighbors <- indset[[i]]
        distances <- dset[[i]]

        # Grid coords of the unlabeled voxel we're filling
        g2 <- grid_diff[voxel_idx, , drop = FALSE]

        # The neighbor indices are indices into cd_atlas, which map back to atlas_idx
        neighbor_lin_idx <- atlas_idx[neighbors]
        neighbor_labels  <- atlas2[neighbor_lin_idx]

        # Weight by inverse distance
        weights <- 1 / (distances + .Machine$double.eps)
        label_votes <- tapply(weights, neighbor_labels, sum)
        chosen_label <- as.numeric(names(which.max(label_votes)))

        # Store (x, y, z, chosen_label)
        out_list[[i]] <- cbind(g2, chosen_label)
    }

    # Combine rows
    out_df <- do.call(rbind, out_list)

    # Convert (x,y,z) back to linear indices
    sub2ind <- function(sz, xyz) {
        # xyz is Nx3
        (xyz[,3] - 1) * sz[1] * sz[2] + (xyz[,2] - 1) * sz[1] + xyz[,1]
    }
    new_lin_idx <- sub2ind(dims, out_df[, 1:3, drop = FALSE])

    # Assign chosen labels
    atlas2[new_lin_idx] <- out_df[, 4]

    # Check that we haven't introduced any labels not present in label_map
    unique_labels <- unique(atlas2[atlas2 != 0])
    missing_labels <- setdiff(unique_labels, unlist(atlas$atlas@label_map))
    if (length(missing_labels) > 0) {
        stop(sprintf(
            "Found labels in dilated atlas that are not in label_map: %s",
            paste(missing_labels, collapse = ", ")
        ))
    }

    # Create the new dilated ClusteredNeuroVol
    dilated_vol <- neuroim2::ClusteredNeuroVol(
        mask    = as.logical(atlas2),
        clusters = atlas2[atlas2 != 0],
        label_map = atlas$atlas@label_map
    )

    # Now return an atlas object (with the same fields/classes as the input).
    # We replace only the $atlas slot with the dilated volume.
    new_atlas <- atlas
    new_atlas$atlas <- dilated_vol

    # Preserve the class of the original atlas
    class(new_atlas) <- class(atlas)

    new_atlas
}
</file>

<file path="R/atlas.R">
#' Print Method for Atlas Objects
#'
#' @description
#' Displays a formatted summary of an atlas object, including its name, dimensions,
#' number of regions, and a color-coded breakdown of anatomical structures.
#'
#' @param x An object of class 'atlas'
#' @param ... Additional arguments passed to print methods
#'
#' @details
#' This print method provides a visually enhanced display of atlas information using
#' colored output via the crayon package. It shows:
#' \itemize{
#'   \item Atlas name and type
#'   \item Volume dimensions and spacing
#'   \item Total number of regions
#'   \item Summary of anatomical structures by hemisphere
#' }
#'
#' @importFrom crayon bold green blue red white
#' @importFrom cli rule symbol
#' @export
print.atlas <- function(x, ...) {
  # Header
  cat(cli::rule(left = crayon::bold("Atlas Summary"), col = "cyan", width = 60), "\n\n")
  
  # Basic info
  cat(crayon::blue(cli::symbol$pointer), " ", 
      crayon::bold("Name:   "), crayon::white(x$name), "\n", sep="")
  
  # Volume info
  dims <- dim(x$atlas)
  cat(crayon::blue(cli::symbol$pointer), " ",
      crayon::bold("Dimensions: "), 
      crayon::white(paste0(dims[1], " × ", dims[2], " × ", dims[3])), "\n", sep="")
  
  # Region counts
  cat(crayon::blue(cli::symbol$pointer), " ",
      crayon::bold("Regions: "), 
      crayon::green(length(x$ids)), "\n", sep="")
  
  # Hemisphere breakdown
  left_count <- sum(x$hemi == "left", na.rm=TRUE)
  right_count <- sum(x$hemi == "right", na.rm=TRUE)
  bilateral_count <- sum(is.na(x$hemi))
  
  cat("\n", crayon::bold("Structure Distribution:"), "\n", sep="")
  cat(crayon::red("├─"), " Left hemisphere:     ", 
      crayon::white(left_count), "\n", sep="")
  cat(crayon::red("├─"), " Right hemisphere:    ", 
      crayon::white(right_count), "\n", sep="")
  cat(crayon::red("└─"), " Bilateral/Midline:   ", 
      crayon::white(bilateral_count), "\n", sep="")
  
  # Footer
  cat("\n", cli::rule(col = "cyan", width = 60), "\n", sep="")
}

#' Create Cache Directory for Atlas Data
#'
#' @description
#' Creates a hidden directory in the user's home folder for caching atlas data.
#'
#' @return Character string containing the path to the cache directory
#' @keywords internal
#' @noRd
create_cache_dir <- function() {
  dname <- paste0(Sys.getenv("HOME"), "/.neuroatlas_cache")
  if (!dir.exists(dname)) {
    dir.create(dname)
  }
  dname
}

#' Get Cache Directory Path
#'
#' @description
#' Returns the path to the atlas cache directory, creating it if necessary.
#'
#' @return Character string containing the path to the cache directory
#' @keywords internal
#' @noRd
get_cache_dir <- function() {
  create_cache_dir()
}

#' Clear Atlas Cache
#'
#' @description
#' Removes all cached atlas files from the cache directory.
#'
#' @return None
#' @keywords internal
#' @noRd
clear_cache <- function() {
  dname <- paste0(Sys.getenv("HOME"), "/.neuroatlas_cache")
  fnames <- list.files(dname, full.names=TRUE)
  sapply(fnames, unlink)
}

#' Merge Two Brain Atlases
#'
#' @description
#' Combines two brain atlases into a single unified atlas object, preserving all
#' region information and adjusting region IDs to prevent conflicts. This is useful
#' for creating composite atlases that combine different parcellation schemes.
#'
#' @details
#' The merging process:
#' \itemize{
#'   \item Verifies that both atlases have the same dimensions
#'   \item Adjusts region IDs in the second atlas to avoid overlap
#'   \item Combines color maps, labels, and hemisphere information
#'   \item Creates a new ClusteredNeuroVol object for the merged atlas
#' }
#'
#' @param atlas1 The first atlas object to merge
#' @param atlas2 The second atlas object to merge
#'
#' @return A new atlas object containing:
#' \describe{
#'   \item{name}{Combined names of input atlases (atlas1::atlas2)}
#'   \item{atlas}{Combined \code{ClusteredNeuroVol} object}
#'   \item{cmap}{Combined colormap for all regions}
#'   \item{ids}{Adjusted vector of all region IDs}
#'   \item{labels}{Combined vector of region labels}
#'   \item{orig_labels}{Original labels from both atlases}
#'   \item{hemi}{Combined hemisphere designations}
#' }
#'
#' @examples
#' \dontrun{
#' # Load two atlases
#' atlas1 <- get_aseg_atlas()
#' atlas2 <- get_aseg_atlas()
#'
#' # Merge the atlases
#' merged <- merge_atlases(atlas1, atlas2)
#'
#' # Check the combined regions
#' print(merged)
#' }
#'
#' @seealso
#' \code{\link{get_aseg_atlas}}, \code{\link{get_roi}}
#'
#' @importFrom assertthat assert_that
#' @importFrom neuroim2 NeuroVol ClusteredNeuroVol space
#' @export
merge_atlases <- function(atlas1, atlas2) {
  assertthat::assert_that(all(dim(atlas1$atlas) == dim(atlas2$atlas)))

  atl2 <- atlas2$atlas
  atl2[atl2 != 0] <- atl2[atl2 != 0] + max(atlas1$ids) 
  atlmerged <- neuroim2::NeuroVol(as.numeric(atlas1$atlas@data), space=space(atlas1$atlas))
  
  
  atlmerged[atl2 != 0] <- atl2[atl2 != 0]
  
  #vol <- neuroim2::ClusteredNeuroVol(as.logical(vol), clusters=vol[vol!=0], 
  #                                   label_map=label_map)
  
  ids <- atlmerged[atlmerged != 0]
  cids <- 1:length(unique(ids))
  label_map <- as.list(cids)
  names(label_map) <- c(atlas1$orig_labels, atlas2$orig_labels)
  
  atlmerged <- neuroim2::ClusteredNeuroVol(as.logical(atlmerged),
                                           clusters=atlmerged[atlmerged != 0],
                                           label_map=label_map)
                                           
  

  ret <- list(
    name=paste0(atlas1$name,"::", atlas2$name),
    atlas=atlmerged,
    cmap=rbind(atlas1$cmap, atlas2$cmap),
    ids=c(atlas1$ids, atlas2$ids + max(atlas1$ids) + 1),
    labels=c(atlas1$labels, atlas2$labels),
    orig_labels=c(atlas1$orig_labels, atlas2$orig_labels),
    hemi=c(atlas1$hemi, atlas2$hemi)
  )

  class(ret) <- c(paste0(atlas1$name,"::", atlas2$name), "atlas")
  ret
}


#' @importFrom neuroim2 space ROIVol index_to_grid
get_roi.atlas <- function(x, label, id=NULL, hemi=NULL) {
  if (!is.null(label) && !is.null(id)) {
    stop("must supply one of 'id' or 'label' but not both")
  }

  if (!is.null(label)) {
    ret <- lapply(label, function(l) {
      id <- x$ids[which(x$labels == l)]
      if (length(id) == 0) {
        stop(paste0("label '", l, "' not found in atlas"))
      }
      rind <- which(x$atlas %in% id)
      neuroim2::ROIVol(neuroim2::space(x$atlas),
                       coords = neuroim2::index_to_grid(x$atlas, rind),
                       data=x$atlas[rind])
    })

    names(ret) <- label
    ret
  } else {
    ret <- lapply(id, function(i) {
      rind <- which(x$atlas %in% i)
      neuroim2::ROIVol(neuroim2::space(x$atlas),coords = neuroim2::index_to_grid(x$atlas, rind),data=i)
    })
    names(ret) <- id
    ret
  }
}

#' @rdname reduce_atlas
#' @export
#' @method reduce_atlas atlas
reduce_atlas.atlas <- function(atlas, data_vol, stat_func, ...) {

  # --- Input Validation ---
  if (!methods::is(data_vol, "NeuroVol") && !methods::is(data_vol, "NeuroVec")) {
    stop("'data_vol' must be a NeuroVol or NeuroVec object.")
  }
  if (!is.function(stat_func)) {
    stop("'stat_func' must be a function.")
  }

  # --- Determine ROI definition volume from 'atlas' (which is an 'atlas' object) ---
  # For an 'atlas' class object, the ROI definition is expected in atlas$atlas
  roi_definition_vol <- NULL
  if (!is.null(atlas$atlas) && methods::is(atlas$atlas, "NeuroVol")) {
    roi_definition_vol <- atlas$atlas
  } else if (!is.null(atlas$data) && methods::is(atlas$data, "NeuroVol")) { 
    # This handles Glasser-like structures if they are passed directly and are also of class 'atlas'
    # However, typically for a well-defined 'atlas' object, atlas$atlas is primary.
    # Consider if Glasser objects should have their own S3 method reduce_atlas.glasser_atlas if structure differs significantly
    # For now, this provides a fallback if atlas$atlas is not present but atlas$data is.
    roi_definition_vol <- atlas$data
  }

  if (is.null(roi_definition_vol)) {
    stop("Could not determine the ROI definition volume from the input 'atlas' object. Expected a NeuroVol in element 'atlas$atlas' or 'atlas$data'.")
  }

  # --- Extract data using neuroim2::extract_roi_data ---
  extracted_values <- neuroim2::extract_roi_data(data_vol, roi_definition_vol, fun = stat_func, ...)

  # --- Convert to tibble ---
  result_tibble <- NULL
  if (is.vector(extracted_values)) {
    result_tibble <- tibble::as_tibble(as.list(extracted_values))
  } else if (is.matrix(extracted_values)) {
    transposed_matrix <- t(extracted_values)
    result_tibble <- tibble::as_tibble(transposed_matrix)
    result_tibble <- tibble::add_column(result_tibble, time = 1:nrow(result_tibble), .before = TRUE)
  } else {
    stop("Unexpected output format from neuroim2::extract_roi_data. Expected vector or matrix.")
  }

  return(result_tibble)
}
</file>

<file path="DESCRIPTION">
Package: neuroatlas
Title: useful atlases/parcellations for neuroimaging analysis
Version: 0.0.0.9000
Authors@R: 
    person(given = "Bradley",
           family = "Buchsbaum",
           role = c("aut", "cre"),
           email = "brad.buchsbaum@gmail.com")
Description: Provides access to several neuroimaging atlases and parcellations
License: What license it uses
Encoding: UTF-8
LazyData: true
RoxygenNote: 7.3.2.9000
Imports:
  rflann,
  downloader,
  reticulate,
  dplyr,
  geojsonsf,
  ggseg,
  ggsegGlasser,
  ggsegSchaefer,
  scico,
  ggiraph,
  neurosurf
Remotes: 
  YeeJeremy/rflann,
  bbuchsbaum/neuroim2,
  bbuchsbaum/neurosurf,
  bbuchsbaum/ggseg,
  ggseg/ggsegGlasser,
  ggseg/ggsegSchaefer
Suggests:
  geojsonio,
  echarts4r,
  geojsonsf
</file>

<file path="R/schaefer.R">
#' Base URL for Schaefer Atlas Files
#' @keywords internal
#' @noRd
schaefer_path <- list(
  rpath = "https://raw.githubusercontent.com/ThomasYeoLab/CBIG/master/stable_projects/brain_parcellation/Schaefer2018_LocalGlobal/Parcellations/MNI/"
)

#' Find Mode of a Vector
#'
#' @description
#' Internal helper function to find the most frequent value in a vector.
#'
#' @param v Numeric vector
#' @return The most frequent value in the vector
#' @keywords internal
#' @noRd
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

#' Resample Volume to New Space
#'
#' @description
#' Resamples a volume to a new space with optional smoothing of parcel boundaries.
#' This is particularly useful for atlas parcellations where maintaining discrete
#' labels is important.
#'
#' @details
#' The resampling process:
#' \itemize{
#'   \item First performs nearest-neighbor interpolation to the new space
#'   \item Optionally smooths boundaries using a local majority voting scheme
#'   \item Preserves zeros in the mask (background)
#' }
#'
#' @param vol A NeuroVol object to be resampled
#' @param outspace A NeuroSpace object specifying the target space
#' @param smooth Logical. Whether to apply boundary smoothing after resampling.
#'   Default: FALSE
#' @param interp Integer. Interpolation method (0=nearest neighbor, 1=linear).
#'   Default: 0
#' @param radius Numeric. Radius for smoothing neighborhood in voxels.
#'   If NULL, uses max(spacing)+0.5. Default: NULL
#' @param min_neighbors Integer. Minimum number of neighbors required for smoothing.
#'   Default: 3
#'
#' @return A resampled NeuroVol object in the new space
#'
#' @importFrom assertthat assert_that
#' @importFrom neuroim2 resample searchlight_coords spacing
#' @export
resample <- function(vol, outspace, smooth=FALSE, interp=0, radius=NULL,
                    min_neighbors=3) {
  # Input validation
  assertthat::assert_that(inherits(vol, "NeuroVol"),
                         msg="'vol' must be a NeuroVol object")
  assertthat::assert_that(inherits(outspace, "NeuroSpace"),
                         msg="'outspace' must be a NeuroSpace object")
  assertthat::assert_that(length(dim(outspace)) == 3,
                         msg="'outspace' must have 3 dimensions")
  assertthat::assert_that(interp %in% c(0,1),
                         msg="'interp' must be 0 (nearest) or 1 (linear)")
  if (!is.null(radius)) {
    assertthat::assert_that(radius > 0,
                           msg="'radius' must be positive")
  }
  assertthat::assert_that(min_neighbors >= 2,
                         msg="'min_neighbors' must be >= 2")

  # Store original labels for validation
  orig_labels <- sort(unique(as.vector(vol[vol != 0])))

  # Initial resampling
  vol <- neuroim2::resample(vol, outspace, interpolation=interp)
  vol2 <- vol

  if (smooth) {
    ds <- spacing(vol)
    mask <- as.logical(vol != 0)

    # Set radius if not provided
    if (is.null(radius)) {
      radius <- max(ds) + 0.5
    }

    sl <- neuroim2::searchlight_coords(mask, radius=radius, nonzero=TRUE)

    for (i in 1:length(sl)) {
      cds <- sl[[i]]

      if (nrow(cds) >= min_neighbors) {
        labels <- vol[cds]
        center_label <- labels[1]
        neighbor_labels <- labels[2:length(labels)]

        # Modified smoothing logic: smooth if majority differs from center
        if (sum(neighbor_labels != center_label) > length(neighbor_labels)/2) {
          md <- getmode(labels)
          if (md != 0) {
            vol2[cds[1,,drop=FALSE]] <- md
          }
        }
      }
    }

    # Preserve mask
    vol2[mask == 0] <- 0
    vol <- vol2
  }

  # Validate output
  final_labels <- sort(unique(as.vector(vol[vol != 0])))
  if (!all(final_labels %in% orig_labels)) {
    warning("Resampling introduced new label values")
  }
  if (!all(orig_labels %in% final_labels)) {
    warning("Some original labels were lost during resampling")
  }

  vol
}

#' Load Schaefer Atlas Volume
#'
#' @description
#' Internal function to download and load Schaefer atlas volume files.
#'
#' @param parcels Number of parcels
#' @param networks Number of networks
#' @param resolution Resolution in mm
#' @param use_cache Whether to use cached files
#' @return A NeuroVol object containing the atlas
#' @keywords internal
#' @noRd
load_schaefer_vol <- function(parcels, networks, resolution, use_cache=TRUE) {
  fname <- paste0("Schaefer2018_", parcels, "Parcels_",
                 networks, "Networks_order_FSLMNI152_", resolution, "mm.nii.gz")

  vol <- if (use_cache) {
    pname <- paste0(get_cache_dir(), "/", fname)
    if (file.exists(pname)) {
      read_vol(pname)
    }
  }

  if (is.null(vol)) {
    path <- paste0(schaefer_path$rpath, fname)
    des <- paste0(tempdir(), "/", fname)
    ret <- downloader::download(path, des)
    vol <- read_vol(des)
    write_vol(vol, paste0(get_cache_dir(), "/", fname))
  }

  vol
}

#' @noRd
#' @keywords internal
load_schaefer_labels <- function(parcels, networks, use_cache=TRUE) {
  label_name <- paste0("Schaefer2018_", parcels, "Parcels_", networks, "Networks_order.txt")
  labels <- NULL
  if (use_cache) {
    if (file.exists(paste0(get_cache_dir(), "/", label_name))) {
      labels <- read.table(paste0(get_cache_dir(), "/", label_name), header=FALSE, as.is=TRUE)
    }
  }

  if (is.null(labels)) {
    des2 <- paste0(tempdir(), "/", label_name)
    #ret <- downloader::download(paste0(schaefer_path$rpath, label_name), des2)
    message("downloading: ", paste0(schaefer_path$rpath, "/freeview_lut/", label_name))
    ret <- downloader::download(paste0(schaefer_path$rpath, "/freeview_lut/", label_name), des2)
    labels <- read.table(des2, header=FALSE, as.is=TRUE)
    file.copy(des2, paste0(get_cache_dir(), "/", label_name), overwrite=TRUE)
  }

  labels
}


#' @noRd
#' @keywords internal
schaefer_metainfo <- function(parcels, networks, use_cache=TRUE) {
  #browser()
  labels = load_schaefer_labels(parcels, networks, use_cache)

  #browser()
  full_label <- labels[,2]
  labels <- labels[, 1:5]
  names(labels) <- c("roinum", "label", "red", "green", "blue")
  labels$label <- gsub(paste0(networks, "Networks", "_"), "", labels$label)
  hemi <- substr(labels$label, 1,2)
  labels$hemi <- hemi

  labels$hemi <- sapply(strsplit(labels$label, "_"), "[[", 1)
  labels$network <-  sapply(strsplit(labels$label, "_"), "[[", 2)
  labels$name <-   sapply(strsplit(labels$label, "_"), function(x) paste(x[(length(x)-1):length(x)], collapse="_"))

  labels$hemi[hemi == "LH"] <- "left"
  labels$hemi[hemi == "RH"] <- "right"

  labels

}

#' Load Schaefer Brain Parcellation Atlas
#'
#' @description
#' Retrieves and loads the Schaefer brain parcellation atlas, which provides a
#' data-driven parcellation of the cerebral cortex based on both local gradient
#' and global similarity approaches.
#'
#' @details
#' The Schaefer atlas offers multiple resolutions of cortical parcellation
#' (100-1000 parcels) and two network versions (7 or 17 networks). The atlas
#' is based on resting-state functional connectivity from 1489 subjects.
#' Features include:
#' \itemize{
#'   \item Multiple granularity levels (100-1000 parcels)
#'   \item Network assignments (7 or 17 networks)
#'   \item Bilateral parcellation
#'   \item Available in different resolutions (1mm or 2mm)
#' }
#'
#' @param parcels Character string specifying number of parcels.
#'   Options: "100", "200", "300", "400", "500", "600", "800", "1000"
#' @param networks Character string specifying network count.
#'   Options: "7", "17"
#' @param resolution Character string specifying MNI space resolution in mm.
#'   Options: "1", "2"
#' @param outspace Optional \code{NeuroSpace} object for resampling the atlas
#' @param smooth Logical. Whether to smooth parcel boundaries after resampling.
#'   Default: FALSE
#' @param use_cache Logical. Whether to cache downloaded files. Default: TRUE
#'
#' @return A list with classes c("schaefer", "volatlas", "atlas") containing:
#' \describe{
#'   \item{name}{Character string identifying atlas version}
#'   \item{atlas}{\code{ClusteredNeuroVol} object containing the parcellation}
#'   \item{cmap}{Data frame with RGB colors for visualization}
#'   \item{ids}{Integer vector of region IDs}
#'   \item{labels}{Character vector of region names}
#'   \item{orig_labels}{Original region labels from source data}
#'   \item{network}{Network assignment for each region}
#'   \item{hemi}{Hemisphere designation for each region}
#' }
#'
#' @examples
#' \dontrun{
#' # Load 300-parcel atlas with 7 networks
#' atlas <- get_schaefer_atlas(parcels = "300", networks = "7")
#'
#' # Load high-resolution version
#' atlas_hires <- get_schaefer_atlas(parcels = "400",
#'                                  networks = "17",
#'                                  resolution = "1")
#'
#' # Resample to a different space
#' new_space <- neuroim2::NeuroSpace(dim = c(91,109,91),
#'                                  spacing = c(2,2,2))
#' atlas_resampled <- get_schaefer_atlas(parcels = "300",
#'                                      outspace = new_space)
#' }
#'
#' @references
#' Schaefer, A., et al. (2018). Local-Global Parcellation of the Human Cerebral
#' Cortex from Intrinsic Functional Connectivity MRI. Cerebral Cortex, 28(9),
#' 3095-3114.
#'
#' @source
#' \url{https://github.com/ThomasYeoLab/CBIG/}
#'
#' @seealso
#' \code{\link{get_schaefer_surfatlas}} for surface-based version
#'
#' @section Convenience Functions:
#' Shorthand functions are provided for common Schaefer atlas configurations. These functions call \code{get_schaefer_atlas} with the \code{parcels} and \code{networks} arguments pre-set. They all accept \code{resolution} (default "2"), \code{outspace}, \code{smooth}, \code{use_cache}, and \code{...} arguments.
#' \itemize{
#'   \item \code{sy_100_7()}: 100 parcels, 7 networks.
#'   \item \code{sy_100_17()}: 100 parcels, 17 networks.
#'   \item \code{sy_200_7()}: 200 parcels, 7 networks.
#'   \item \code{sy_200_17()}: 200 parcels, 17 networks.
#'   \item \code{sy_300_7()}: 300 parcels, 7 networks.
#'   \item \code{sy_300_17()}: 300 parcels, 17 networks.
#'   \item \code{sy_400_7()}: 400 parcels, 7 networks.
#'   \item \code{sy_400_17()}: 400 parcels, 17 networks.
#'   \item \code{sy_500_7()}: 500 parcels, 7 networks.
#'   \item \code{sy_500_17()}: 500 parcels, 17 networks.
#'   \item \code{sy_600_7()}: 600 parcels, 7 networks.
#'   \item \code{sy_600_17()}: 600 parcels, 17 networks.
#'   \item \code{sy_800_7()}: 800 parcels, 7 networks.
#'   \item \code{sy_800_17()}: 800 parcels, 17 networks.
#'   \item \code{sy_1000_7()}: 1000 parcels, 7 networks.
#'   \item \code{sy_1000_17()}: 1000 parcels, 17 networks.
#' }
#'
#' @importFrom neuroim2 read_vol ClusteredNeuroVol write_vol
#' @importFrom downloader download
#' @importFrom assertthat assert_that
#'
#' @export
get_schaefer_atlas <- function(parcels=c("100","200","300","400","500","600","800","1000"),
                              networks=c("7","17"), resolution=c("1","2"),
                              outspace=NULL, smooth=FALSE, use_cache=TRUE) {

  parcels <- match.arg(as.character(parcels))
  networks <- match.arg(as.character(networks))
  resolution <- match.arg(as.character(resolution))

  # Resolve outspace if it's not NULL and not already a NeuroSpace (T6.1.4)
  if (!is.null(outspace) && !neuroim2::is.NeuroSpace(outspace)) {
    message("Attempting to resolve 'outspace' argument via TemplateFlow...")
    # We need .resolve_template_input to be available. 
    # Assuming it's exported from neuroatlas or accessible.
    # If it's internal, this call would need neuroatlas:::.resolve_template_input
    # For now, assuming it becomes an exported utility or is otherwise accessible.
    # If this file is part of the same package, direct call might work if NAMESPACE handles it.
    resolved_outspace <- tryCatch({
      neuroatlas:::.resolve_template_input(outspace, target_type = "NeuroSpace")
    }, error = function(e) {
      stop("Failed to resolve 'outspace' via TemplateFlow: ", conditionMessage(e),
           "\n'outspace' must be a NeuroSpace object, a TemplateFlow space ID string, or a list of get_template() arguments.")
      return(NULL) # Should be caught by stop
    })
    
    if (is.null(resolved_outspace) || !neuroim2::is.NeuroSpace(resolved_outspace)) {
        stop("Resolution of 'outspace' did not result in a valid NeuroSpace object.")
    }
    outspace <- resolved_outspace # Replace original outspace with the resolved NeuroSpace
  }

  vol <- load_schaefer_vol(parcels, networks, resolution, use_cache)

  if (!is.null(outspace)) {
    #print(outspace)
    assertthat::assert_that(length(dim(outspace)) == 3)
    vol <- resample(vol, outspace, smooth)
  }



  labels <- schaefer_metainfo(parcels, networks, use_cache)
  cids <- 1:nrow(labels)
  label_map <- as.list(cids)
  names(label_map) <- labels$name

  vol <- neuroim2::ClusteredNeuroVol(as.logical(vol), clusters=vol[vol!=0], label_map=label_map)

  ret <- list(
    name=paste0("Schaefer-", parcels, "-", networks, "networks"),
    atlas=vol,
    cmap=labels[,3:5],
    ids=1:nrow(labels),
    labels=labels$name,
    orig_labels=labels[,2],
    network=labels$network,
    hemi=labels$hemi)

  class(ret) <- c("schaefer", "volatlas", "atlas")
  ret
}


#' Load Surface-Based Schaefer Atlas
#'
#' @description
#' Loads the surface-based version of the Schaefer parcellation atlas, compatible
#' with FreeSurfer surface representations.
#'
#' @details
#' Provides the Schaefer parcellation mapped to FreeSurfer surface meshes. The
#' atlas can be loaded onto different surface representations (inflated, white,
#' or pial) and maintains the same parcellation scheme as the volumetric version.
#'
#' @param parcels Character string specifying number of parcels.
#'   Options: "100", "200", "300", "400", "500", "600", "800", "1000"
#' @param networks Character string specifying network count.
#'   Options: "7", "17"
#' @param surf Character string specifying surface type.
#'   Options: "inflated", "white", "pial"
#' @param use_cache Logical. Whether to cache downloaded files. Default: TRUE
#'
#' @return A list with classes c("schaefer", "surfatlas", "atlas") containing:
#' \describe{
#'   \item{surf_type}{Surface type used}
#'   \item{lh_atlas}{Left hemisphere surface atlas}
#'   \item{rh_atlas}{Right hemisphere surface atlas}
#'   \item{name}{Atlas identifier}
#'   \item{cmap}{RGB color specifications}
#'   \item{ids}{Region IDs}
#'   \item{labels}{Region names}
#'   \item{orig_labels}{Original region labels}
#'   \item{network}{Network assignments}
#'   \item{hemi}{Hemisphere designations}
#' }
#'
#' @examples
#' \dontrun{
#' # Load inflated surface atlas
#' surf_atlas <- get_schaefer_surfatlas(parcels = "300",
#'                                     networks = "7",
#'                                     surf = "inflated")
#'
#' # Load pial surface version
#' pial_atlas <- get_schaefer_surfatlas(parcels = "400",
#'                                     networks = "17",
#'                                     surf = "pial")
#' }
#'
#' @seealso
#' \code{\link{get_schaefer_atlas}} for volumetric version
#'
#' @importFrom neurosurf read_freesurfer_annot
#' @importFrom downloader download
#' @export
get_schaefer_surfatlas <- function(parcels=c("100","200","300","400","500","600","800","1000"),
                                  networks=c("7","17"), surf=c("inflated", "white", "pial"),
                                  use_cache=TRUE) {


  #https://github.com/ThomasYeoLab/CBIG/blob/master/stable_projects/brain_parcellation/Schaefer2018_LocalGlobal/Parcellations/FreeSurfer5.3/fsaverage6/label/lh.Schaefer2018_1000Parcels_17Networks_order.annot

  parcels <- match.arg(parcels)
  networks <- match.arg(networks)
  surf <- match.arg(surf)
  #resolution <- match.arg(resolution)

  data(fsaverage)

  get_hemi <- function(hemi) {

    fname <- paste0(hemi, ".", "Schaefer2018_", parcels, "Parcels_", networks, "Networks_order.annot")

    rpath <- "https://raw.githubusercontent.com/ThomasYeoLab/CBIG/master/stable_projects/brain_parcellation/Schaefer2018_LocalGlobal/Parcellations/FreeSurfer5.3/fsaverage6/label/"
    path <- paste0(rpath,fname)

    des <- paste0(tempdir(), "/", fname)
    ret <- downloader::download(path, des)

    geom <- paste0(hemi, "_", surf)
    annot <- neurosurf::read_freesurfer_annot(des, fsaverage[[geom]])

    nrois <- as.integer(parcels)

    if (hemi == "rh") {
      annot@data <- annot@data + nrois/2
      annot@data <- annot@data - 1
      annot@data[annot@data == nrois/2] <- 0
      annot@labels <- annot@labels[-1]
    } else {
      annot@data <- annot@data - 1
      annot@labels <- annot@labels[-1]
    }

    annot

  }


  ##rp <-  "https://raw.githubusercontent.com/ThomasYeoLab/CBIG/master/stable_projects/brain_parcellation/Schaefer2018_LocalGlobal/Parcellations/MNI/"

  labels <- schaefer_metainfo(parcels, networks, use_cache=use_cache)
  #browser()
  lh_surf <- get_hemi("lh")
  rh_surf <- get_hemi("rh")

  ret <- list(
    surf_type=surf,
    lh_atlas = lh_surf,
    rh_atlas = rh_surf,
    name=paste0("Schaefer-", parcels, "-", networks, "networks"),
    cmap=labels[,3:5],
    ids=1:nrow(labels),
    labels=labels$name,
    orig_labels=labels[,2],
    network=labels$network,
    hemi=labels$hemi)

  class(ret) <- c("schaefer", "surfatlas", "atlas")
  ret
}



#' @rdname get_schaefer_atlas
#' @export
sy_100_7 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "100", networks = "7", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_100_17 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "100", networks = "17", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_200_7 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "200", networks = "7", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_200_17 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "200", networks = "17", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_300_7 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "300", networks = "7", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_300_17 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "300", networks = "17", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_400_7 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "400", networks = "7", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_400_17 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "400", networks = "17", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_500_7 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "500", networks = "7", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_500_17 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "500", networks = "17", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_600_7 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "600", networks = "7", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_600_17 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "600", networks = "17", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_800_7 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "800", networks = "7", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_800_17 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "800", networks = "17", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_1000_7 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "1000", networks = "7", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}

#' @rdname get_schaefer_atlas
#' @export
sy_1000_17 <- function(resolution = "2", outspace = NULL, smooth = FALSE, use_cache = TRUE, ...) {
  get_schaefer_atlas(parcels = "1000", networks = "17", resolution = resolution,
                     outspace = outspace, smooth = smooth, use_cache = use_cache, ...)
}
</file>

</files>
