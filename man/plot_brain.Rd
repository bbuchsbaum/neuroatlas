% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_brain.R
\name{plot_brain}
\alias{plot_brain}
\title{Plot Brain Surface Atlas}
\usage{
plot_brain(
  surfatlas,
  vals = NULL,
  views = c("lateral", "medial"),
  hemis = c("left", "right"),
  surface = "inflated",
  color_method = "rule_hcl",
  colors = NULL,
  palette = "cork",
  lim = NULL,
  interactive = TRUE,
  data_id_mode = c("parcel", "polygon"),
  ncol = 2L,
  panel_layout = c("native", "presentation"),
  style = c("default", "ggseg_like"),
  border = TRUE,
  border_geom = c("path", "segment"),
  boundary_smooth = 0L,
  projection_smooth = 0L,
  border_color = "grey30",
  border_size = 0.15,
  border_lineend = "round",
  border_linejoin = "round",
  silhouette = border,
  silhouette_color = border_color,
  silhouette_size = border_size,
  network_border = FALSE,
  network_border_color = border_color,
  network_border_size = border_size * 2,
  shading = FALSE,
  shading_strength = 0.22,
  shading_gamma = 1,
  shading_color = "black",
  fill_alpha = 1,
  overlay = NULL,
  overlay_threshold = NULL,
  overlay_alpha = 0.45,
  overlay_palette = "vik",
  overlay_lim = NULL,
  overlay_border = TRUE,
  overlay_border_color = "black",
  overlay_border_size = 0.25,
  overlay_fun = c("avg", "nn", "mode"),
  overlay_sampling = c("midpoint", "normal_line", "thickness"),
  colorbar = FALSE,
  colorbar_title = NULL,
  outline = FALSE,
  bg = "white",
  ...
)
}
\arguments{
\item{surfatlas}{A surface atlas object of class \code{"surfatlas"}
(e.g. from \code{\link{schaefer_surf}()} or \code{\link{glasser_surf}()}).}

\item{vals}{Optional numeric vector of values to map onto parcels. Length
must equal the number of atlas regions (\code{length(surfatlas$ids)}).
When \code{NULL} (default), parcels are coloured using the ROI colour
system.}

\item{views}{Character vector of views to render. Any combination of
\code{"lateral"}, \code{"medial"}, \code{"dorsal"}, \code{"ventral"}.
Default: \code{c("lateral", "medial")}.}

\item{hemis}{Character vector of hemispheres to include.
Default: \code{c("left", "right")}.}

\item{surface}{Surface type. One of \code{"inflated"}, \code{"pial"},
\code{"white"}. Must match the surface type of \code{surfatlas}.}

\item{color_method}{Colour algorithm for discrete parcel colouring (when
\code{vals} is \code{NULL}). Passed to \code{\link{atlas_roi_colors}()}.
Default: \code{"rule_hcl"}.}

\item{colors}{Optional pre-computed colours: a tibble with \code{id} and
\code{color} columns, or a named character vector of hex colours keyed
by region ID. Overrides \code{color_method} when \code{vals} is
\code{NULL}.}

\item{palette}{Character: scico palette for continuous colour scale (when
\code{vals} is provided). Default: \code{"cork"}.}

\item{lim}{Numeric vector of length 2 for colour scale limits (continuous
mode). Defaults to range of \code{vals}.}

\item{interactive}{Logical. If \code{TRUE} (default), returns a
\code{ggiraph::girafe} widget with hover tooltips. If \code{FALSE},
returns a static \code{ggplot2} object.}

\item{data_id_mode}{Interactive data-id granularity (when
\code{interactive = TRUE}): \code{"parcel"} (default) uses parcel ids;
\code{"polygon"} encodes panel + parcel + polygon/face id for
click-to-surface workflows.}

\item{ncol}{Integer: number of columns in the facet layout. Default: 2.}

\item{panel_layout}{Panel coordinate layout strategy:
\code{"native"} (default) preserves raw projected units;
\code{"presentation"} recentres each panel, rotates dorsal/ventral views
to horizontal, and normalises per-panel scale for a cleaner ggseg-like
grid.}

\item{style}{Visual preset. \code{"default"} keeps existing behaviour.
\code{"ggseg_like"} enables a cleaner publication style and, unless
explicitly overridden, switches \code{panel_layout} to
\code{"presentation"} with softer border defaults and light projection
smoothing.}

\item{border}{Logical. If \code{TRUE} (default), draw thin lines at parcel
boundaries (edges between different parcels). Gives a clean ggseg-like
appearance.}

\item{border_geom}{Boundary rendering method. \code{"path"} (default) chains
boundary edges into longer paths for smoother lines; \code{"segment"} draws
each boundary edge independently.}

\item{boundary_smooth}{Non-negative integer controlling Chaikin smoothing
iterations applied to boundary paths when \code{border_geom = "path"}.
\code{0} (default) keeps original mesh-aligned boundaries; \code{1} or
\code{2} yields cleaner curves in close-up figures.}

\item{projection_smooth}{Non-negative integer controlling Laplacian-like
smoothing iterations applied to projected vertex coordinates before parcel
polygons are constructed. This smooths filled parcel edges while
preserving shared boundaries across parcels. \code{0} (default) keeps raw
projected coordinates.}

\item{border_color}{Colour for parcel boundary lines. Default:
\code{"grey30"}.}

\item{border_size}{Line width for parcel boundaries. Default: \code{0.15}.}

\item{border_lineend}{Line end style for boundary lines (passed to
\code{\link[ggplot2]{geom_path}} / \code{\link[ggplot2]{geom_segment}}).
One of \code{"butt"},
\code{"round"}, \code{"square"}. Default: \code{"round"}.}

\item{border_linejoin}{Line join style for boundary lines (passed to
\code{\link[ggplot2]{geom_path}} / \code{\link[ggplot2]{geom_segment}}).
One of \code{"round"},
\code{"mitre"}, \code{"bevel"}. Default: \code{"round"}.}

\item{silhouette}{Logical. If \code{TRUE}, draw the mesh silhouette (edges
between visible and culled faces) as a separate boundary layer. Defaults
to \code{border}.}

\item{silhouette_color}{Colour for silhouette lines. Default:
\code{border_color}.}

\item{silhouette_size}{Line width for silhouette lines. Default:
\code{border_size}.}

\item{network_border}{Logical. If \code{TRUE}, highlight boundaries between
different networks (requires \code{surfatlas$network}). Default:
\code{FALSE}.}

\item{network_border_color}{Colour for network boundary lines. Default:
\code{border_color}.}

\item{network_border_size}{Line width for network boundary lines. Default:
\code{border_size * 2}.}

\item{shading}{Logical. If \code{TRUE}, overlay a subtle normal-based shading
layer to enhance depth cues (recommended for static figures).}

\item{shading_strength}{Numeric in \code{[0, 1]}. Maximum opacity of the
shading overlay. Default: \code{0.22}.}

\item{shading_gamma}{Positive numeric scalar controlling the shadow falloff.
Higher values concentrate shadows in more oblique regions. Default:
\code{1}.}

\item{shading_color}{Colour of the shading overlay. Default: \code{"black"}.}

\item{fill_alpha}{Numeric in \code{[0, 1]}. Opacity of parcel fills.
Lower values can help the shading read more clearly. Default: \code{1}.}

\item{overlay}{Vertex-wise overlay or a \code{NeuroVol}.
If a \code{NeuroVol}, it is automatically projected onto the surface
using \code{neurosurf::vol_to_surf()}.
Otherwise, a list with \code{lh} and \code{rh} components (numeric
vectors matching the vertex count of each hemisphere mesh).}

\item{overlay_threshold}{Optional absolute threshold for overlay values
before rendering.}

\item{overlay_alpha}{Numeric in \code{[0, 1]}. Opacity of overlay polygons.
Default: \code{0.45}.}

\item{overlay_palette}{scico palette for overlay colour mapping. Default:
\code{"vik"}.}

\item{overlay_lim}{Optional numeric length-2 limits for overlay colour
mapping.}

\item{overlay_border}{Logical. If \code{TRUE}, draw cluster overlay
boundaries. Default: \code{TRUE}.}

\item{overlay_border_color}{Colour for overlay boundaries. Default:
\code{"black"}.}

\item{overlay_border_size}{Line width for overlay boundaries. Default:
\code{0.25}.}

\item{overlay_fun}{Character: interpolation function passed to
\code{neurosurf::vol_to_surf()} when \code{overlay} is a
\code{NeuroVol}. One of \code{"avg"}, \code{"nn"}, or \code{"mode"}.
Default: \code{"avg"}.}

\item{overlay_sampling}{Character: sampling strategy passed to
\code{neurosurf::vol_to_surf()} when \code{overlay} is a
\code{NeuroVol}. One of \code{"midpoint"}, \code{"normal_line"}, or
\code{"thickness"}. Default: \code{"midpoint"}.}

\item{colorbar}{Logical. When \code{vals} is non-NULL and
\code{interactive = FALSE}, add a standalone colorbar panel composed
alongside the main plot via \pkg{patchwork}. Default: \code{FALSE}.}

\item{colorbar_title}{Optional character label for the colorbar.}

\item{outline}{Logical. If \code{TRUE}, draw every triangle edge (mesh
wireframe). Default: \code{FALSE}. Typically \code{border} is preferred.}

\item{bg}{Character: background colour for the plot. Default: \code{"white"}.}

\item{...}{Additional arguments (currently unused).}
}
\value{
A \code{ggplot2} object (when \code{interactive = FALSE}) or a
  \code{ggiraph::girafe} widget (when \code{interactive = TRUE}).
}
\description{
Renders a triangle-mesh projection of cortical surface parcellations with
configurable views and optional ggiraph interactivity. This function replaces
the legacy ggseg-based visualisation pipeline.
}
\examples{
\dontrun{
atl <- schaefer_surf(200, 17)
plot_brain(atl)
plot_brain(atl, vals = rnorm(200), palette = "vik")
plot_brain(atl, views = "lateral", interactive = FALSE)

# Styling: rounded white parcel borders + thicker silhouette + network edges
plot_brain(
  atl,
  interactive = FALSE,
  border_color = "white",
  border_size = 0.25,
  border_lineend = "round",
  silhouette_size = 0.6,
  network_border = TRUE,
  network_border_color = "grey10",
  network_border_size = 0.5,
  shading = TRUE,
  fill_alpha = 0.98,
  bg = "#f7f7f7"
)
}

}
